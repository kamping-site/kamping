<!-- HTML header for doxygen 1.10.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KaMPIng: kamping::internal Namespace Reference</title>
<link rel="icon" href="icon.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeDarkModeToggle.init()
    </script>
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeFragmentCopyButton.init()
    </script>
    <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeParagraphLink.init()
    </script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="icon.svg"/></td>
  <td id="projectalign">
   <div id="projectname">KaMPIng<span id="projectnumber">&#160;0.2.1</span>
   </div>
   <div id="projectbrief">(Near) zero-overhead MPI wrapper for C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespacekamping_1_1internal.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">kamping::internal Namespace Reference<div class="ingroups"><a class="el" href="group__kamping__mpi__utility.html">MPI Utility</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Internal namespace marking the code that is not user-facing.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1all__unique.html">all_unique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base wrapper (<code>std::integral_constant</code>) to test if all types of a tuple are unique.  <a href="structkamping_1_1internal_1_1all__unique.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1all__unique_3_01std_1_1tuple_3_01T_00_01Ts_8_8_8_01_4_01_4.html">all_unique&lt; std::tuple&lt; T, Ts... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive wrapper (<code>std::integral_constant</code>) to test if all types of a tuple are unique. This is done by checking for each type whether the type occurs in the types of the tuple to the right. If this is true for any type/position, the types in the tuple are not unique.  <a href="structkamping_1_1internal_1_1all__unique_3_01std_1_1tuple_3_01T_00_01Ts_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1AllocNewDataBufferBuilder.html">AllocNewDataBufferBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter object representing a data buffer to be allocated by KaMPIng. This is a specialization of <a class="el" href="structkamping_1_1internal_1_1DataBufferBuilder.html">DataBufferBuilder</a> for buffer allocation tags, such as <a class="el" href="group__kamping__mpi__utility.html#gaf7e87045435196cd49a0c3adcdf7c307">alloc_new</a>, <a class="el" href="group__kamping__mpi__utility.html#gad844f328b457a676276a88418c98b8ac">alloc_new_using</a> and <a class="el" href="group__kamping__mpi__utility.html#ga70881031449cce5df630e5ad77a3299d">alloc_container_of</a>. This is an intermediate object not holding any data. The actual buffer is constructed by calling the <code><a class="el" href="structkamping_1_1internal_1_1AllocNewDataBufferBuilder.html#a1b2241053873b9c888e3a463ba41a44a" title="Constructs the data buffer.">construct_buffer_or_rebind()</a></code> method.  <a href="structkamping_1_1internal_1_1AllocNewDataBufferBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1any__tag__t.html">any_tag_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">tag struct for message tag  <a href="structkamping_1_1internal_1_1any__tag__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1buffered__mode__t.html">buffered_mode_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">tag for buffered send mode  <a href="structkamping_1_1internal_1_1buffered__mode__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1CallableWrapper.html">CallableWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around a functor <code>F</code> that makes it callable using the <code>call</code> method.  <a href="structkamping_1_1internal_1_1CallableWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkamping_1_1internal_1_1CopyMoveEnabler.html">CopyMoveEnabler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class optionally containing a copy constructor while supporting move assignment/construction.  <a href="classkamping_1_1internal_1_1CopyMoveEnabler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkamping_1_1internal_1_1CopyMoveEnabler_3_01true_01_4.html">CopyMoveEnabler&lt; true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of ParameterObjectBase which possesses a copy constructor.  <a href="classkamping_1_1internal_1_1CopyMoveEnabler_3_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkamping_1_1internal_1_1DataBuffer.html">DataBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data buffer used for named parameters.  <a href="classkamping_1_1internal_1_1DataBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1DataBufferBuilder.html">DataBufferBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter object representing a data buffer. This is an intermediate object which only holds the data and parameters. The actual buffer is created by calling the <code><a class="el" href="structkamping_1_1internal_1_1DataBufferBuilder.html#ae6b24d0cd9757cefaab259c078603695" title="Constructs the data buffer.">construct_buffer_or_rebind()</a></code> method.  <a href="structkamping_1_1internal_1_1DataBufferBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1default__value__type__tag.html">default_value_type_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">tag type to indicate that the value_type should be inferred from the container  <a href="structkamping_1_1internal_1_1default__value__type__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1DiscardSerializationBuffers.html">DiscardSerializationBuffers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate to check whether a buffer provided to <a class="el" href="#aad256a920b44aef089a398b516864694">make_mpi_result()</a> shall be discard or returned in the result object, including a hotfix for serialization.  <a href="structkamping_1_1internal_1_1DiscardSerializationBuffers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkamping_1_1internal_1_1EmptyDataBuffer.html">EmptyDataBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty buffer that can be used as default argument for optional buffer parameters.  <a href="classkamping_1_1internal_1_1EmptyDataBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkamping_1_1internal_1_1Extractable.html">Extractable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class containing logic to verify whether a buffer's data has already been extracted. This only has effects if an appropiate assertion level is set.  <a href="classkamping_1_1internal_1_1Extractable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1FilterOut.html">FilterOut</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template used to filter a list of types and only keep those whose types meet specified criteria. See the following specialisations for more information.  <a href="structkamping_1_1internal_1_1FilterOut.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1FilterOut_3_01Predicate_01_4.html">FilterOut&lt; Predicate &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of template class used to filter a list of types and only keep the those whose types meet the specified criteria.  <a href="structkamping_1_1internal_1_1FilterOut_3_01Predicate_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1FilterOut_3_01Predicate_00_01Head_00_01Tail_8_8_8_01_4.html">FilterOut&lt; Predicate, Head, Tail... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of template class used to filter a list of (buffer-)types and discard those for which The template is recursively instantiated to check one type after the other and "insert" it into a std::tuple if it meets the criteria . based on <a href="https://stackoverflow.com/a/18366475">https://stackoverflow.com/a/18366475</a>.  <a href="structkamping_1_1internal_1_1FilterOut_3_01Predicate_00_01Head_00_01Tail_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1FilterOut_3_01Predicate_00_01std_1_1tuple_3_01Types_8_8_8_01_4_01_4.html">FilterOut&lt; Predicate, std::tuple&lt; Types... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of template class for types stored in a std::tuple&lt;...&gt; that is used to filter these types and only keep those which meet certain criteria (see above).  <a href="structkamping_1_1internal_1_1FilterOut_3_01Predicate_00_01std_1_1tuple_3_01Types_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1FlatContainer.html">FlatContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a container to is underlying nested container.  <a href="structkamping_1_1internal_1_1FlatContainer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1FlatContainer_3_01T_00_01std_1_1enable__if__t_3_01is__nested__send__buffer__v_3_01T_01_4_01_4_01_4.html">FlatContainer&lt; T, std::enable_if_t&lt; is_nested_send_buffer_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a container to is underlying nested container.  <a href="structkamping_1_1internal_1_1FlatContainer_3_01T_00_01std_1_1enable__if__t_3_01is__nested__send__buffer__v_3_01T_01_4_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1FlatContainer_3_01T_00_01std_1_1enable__if__t_3_01is__sparse__send__buffer__v_3_01T_01_4_01_4_01_4.html">FlatContainer&lt; T, std::enable_if_t&lt; is_sparse_send_buffer_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a container to is underlying nested container.  <a href="structkamping_1_1internal_1_1FlatContainer_3_01T_00_01std_1_1enable__if__t_3_01is__sparse__send__buffer__v_3_01T_01_4_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkamping_1_1internal_1_1GenericDataBuffer.html">GenericDataBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A more generic version of a <a class="el" href="classkamping_1_1internal_1_1DataBuffer.html" title="Data buffer used for named parameters.">DataBuffer</a> which stores an object of type.  <a href="classkamping_1_1internal_1_1GenericDataBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1has__data__member.html">has_data_member</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to decide if data type has <code></code>.data() method.  <a href="structkamping_1_1internal_1_1has__data__member.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1has__data__member_3_01T_00_01std_1_1void__t_3_01decltype_07std_1_1dfe1346dc82617c01fb5c64ff94e93db8.html">has_data_member&lt; T, std::void_t&lt; decltype(std::declval&lt; T &gt;().data())&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to decide if data type has <code></code>.data() method.  <a href="structkamping_1_1internal_1_1has__data__member_3_01T_00_01std_1_1void__t_3_01decltype_07std_1_1dfe1346dc82617c01fb5c64ff94e93db8.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1has__no__unused__parameters.html">has_no_unused_parameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct wrapping a check that verifies that no unused parameters are part of the arguments.  <a href="structkamping_1_1internal_1_1has__no__unused__parameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1has__parameter__helper.html">has_parameter_helper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct needed to retrieve the types stored in a std::tuple for the has_parameter_type check.  <a href="structkamping_1_1internal_1_1has__parameter__helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1ignore__t.html">ignore_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type for parameters that can be omitted on some PEs (e.g., root PE, or non-root PEs).  <a href="structkamping_1_1internal_1_1ignore__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1is__specialization.html">is_specialization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to check if a type is an instance of a templated type.  <a href="structkamping_1_1internal_1_1is__specialization.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1is__specialization_3_01Template_3_01Args_8_8_8_01_4_00_01Template_01_4.html">is_specialization&lt; Template&lt; Args... &gt;, Template &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to check if a type is an instance of a templated type.  <a href="structkamping_1_1internal_1_1is__specialization_3_01Template_3_01Args_8_8_8_01_4_00_01Template_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1is__std__array.html">is_std_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to check if a type is a <code>std::array</code>.  <a href="structkamping_1_1internal_1_1is__std__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1is__std__array_3_01std_1_1array_3_01T_00_01N_01_4_01_4.html">is_std_array&lt; std::array&lt; T, N &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to check if a type is a <code>std::array</code>.  <a href="structkamping_1_1internal_1_1is__std__array_3_01std_1_1array_3_01T_00_01N_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1is__std__pair.html">is_std_pair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to check if a type is a <code>std::pair</code>.  <a href="structkamping_1_1internal_1_1is__std__pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1is__std__pair_3_01std_1_1pair_3_01T1_00_01T2_01_4_01_4.html">is_std_pair&lt; std::pair&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to check if a type is a <code>std::pair</code>.  <a href="structkamping_1_1internal_1_1is__std__pair_3_01std_1_1pair_3_01T1_00_01T2_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1is__std__tuple.html">is_std_tuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to check if a type is a <code>std::tuple</code>.  <a href="structkamping_1_1internal_1_1is__std__tuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1is__std__tuple_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_01_4.html">is_std_tuple&lt; std::tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to check if a type is a <code>std::tuple</code>.  <a href="structkamping_1_1internal_1_1is__std__tuple_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1logical__xor__impl.html">logical_xor_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper struct for logical xor, as the standard library does not provide a function object for it.  <a href="structkamping_1_1internal_1_1logical__xor__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1logical__xor__impl_3_01void_01_4.html">logical_xor_impl&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for <code><a class="el" href="structkamping_1_1internal_1_1logical__xor__impl.html" title="Wrapper struct for logical xor, as the standard library does not provide a function object for it.">kamping::internal::logical_xor_impl</a></code> without type parameter, which leaves to operand type to be deduced. The actual implementation is used in case that the operation is a builtin operation for the given datatype.  <a href="structkamping_1_1internal_1_1logical__xor__impl_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1max__impl.html">max_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper struct for std::max.  <a href="structkamping_1_1internal_1_1max__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1max__impl_3_01void_01_4.html">max_impl&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for <code><a class="el" href="structkamping_1_1internal_1_1max__impl.html" title="Wrapper struct for std::max.">kamping::internal::max_impl</a></code> without type parameter, which leaves the operand type to be deduced.  <a href="structkamping_1_1internal_1_1max__impl_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1min__impl.html">min_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper struct for std::min.  <a href="structkamping_1_1internal_1_1min__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1min__impl_3_01void_01_4.html">min_impl&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for <code><a class="el" href="structkamping_1_1internal_1_1min__impl.html" title="Wrapper struct for std::min.">kamping::internal::min_impl</a></code> without type parameter, which leaves the operand type to be deduced. The actual implementation is used in case that the operation is a builtin operation for the given datatype.  <a href="structkamping_1_1internal_1_1min__impl_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1mpi__operation__traits.html">mpi_operation_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for checking whether a functor is a builtin MPI reduction operation and query the corresponding <code>MPI_Op</code>.  <a href="structkamping_1_1internal_1_1mpi__operation__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkamping_1_1internal_1_1OperationBuilder.html">OperationBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter wrapping an operation passed to reduce-like MPI collectives. This wraps an MPI operation without the argument of the operation specified. This enables the user to construct such wrapper using the parameter factory <code><a class="el" href="group__kamping__named__parameters.html#gaa78fb26dabc8cda40e171b2ea229143d" title="Passes a reduction operation to ther underlying call. Accepts function objects, lambdas,...">kamping::op</a></code> without passing the type of the operation. The library developer may then construct the actual operation wrapper with a given type later.  <a href="classkamping_1_1internal_1_1OperationBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1parameter__type__to__integral__constant.html">parameter_type_to_integral_constant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to get an <code>std::integral_constant</code> for a <a class="el" href="group__kamping__utility.html#ga0c6ea899ba6946f984708bfc852d44f1" title="Each input parameter to one of the MPI calls wrapped by KaMPIng needs to has one of the following tag...">kamping::internal::ParameterType</a>.  <a href="structkamping_1_1internal_1_1parameter__type__to__integral__constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1parameter__types__to__integral__constants.html">parameter_types_to_integral_constants</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to get a tuple of <code>std::integral_constant</code> for each <a class="el" href="group__kamping__utility.html#ga0c6ea899ba6946f984708bfc852d44f1" title="Each input parameter to one of the MPI calls wrapped by KaMPIng needs to has one of the following tag...">kamping::internal::ParameterType</a> passed as template parameter that are extracted as tuple of <code>std::integral_constant</code>.  <a href="structkamping_1_1internal_1_1parameter__types__to__integral__constants.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1parameters__to__integral__constant.html">parameters_to_integral_constant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to get a tuple of <code>std::integral_constant</code> for each <a class="el" href="group__kamping__utility.html#ga0c6ea899ba6946f984708bfc852d44f1" title="Each input parameter to one of the MPI calls wrapped by KaMPIng needs to has one of the following tag...">kamping::internal::ParameterType</a> of the parameters.  <a href="structkamping_1_1internal_1_1parameters__to__integral__constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1ParameterTypeEntry.html">ParameterTypeEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class to store an enum entry (<a class="el" href="group__kamping__utility.html#ga0c6ea899ba6946f984708bfc852d44f1">kamping::internal::ParameterType</a>) in a separate type (so that it can be used in a compile time list)  <a href="structkamping_1_1internal_1_1ParameterTypeEntry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1ParameterTypeUnwrapping.html">ParameterTypeUnwrapping</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait struct used to determine the underlying type and value of the parameter type of an object with a parameter type. (This is a building block to enable plugins to have their own named parameters).  <a href="structkamping_1_1internal_1_1ParameterTypeUnwrapping.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1ParameterTypeUnwrapping_3_01std_1_1integral__constant_3_01T_00_01v_01_4_01_4.html">ParameterTypeUnwrapping&lt; std::integral_constant&lt; T, v &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait struct used to determine the underlying type and value of the parameter type of an std::integral_constant wrapping a parameter type. (This is a building block to enable plugins to have their own named parameters).  <a href="structkamping_1_1internal_1_1ParameterTypeUnwrapping_3_01std_1_1integral__constant_3_01T_00_01v_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1PredicateForResultObject.html">PredicateForResultObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate to check whether a buffer provided to <a class="el" href="#aad256a920b44aef089a398b516864694">make_mpi_result()</a> shall be discard or returned in the result object.  <a href="structkamping_1_1internal_1_1PredicateForResultObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1PrependParameterType.html">PrependParameterType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class to prepend the ParameterTypeEntry&lt;ParameterType::ptype&gt; type to a given std::tuple.  <a href="structkamping_1_1internal_1_1PrependParameterType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1PrependType.html">PrependType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template used to concatenate a type to a given std::tuple. based on <a href="https://stackoverflow.com/a/18366475">https://stackoverflow.com/a/18366475</a>.  <a href="structkamping_1_1internal_1_1PrependType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1PrependType_3_01Head_00_01std_1_1tuple_3_01Tail_8_8_8_01_4_01_4.html">PrependType&lt; Head, std::tuple&lt; Tail... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of a class template used to preprend a type to a given std::tuple.  <a href="structkamping_1_1internal_1_1PrependType_3_01Head_00_01std_1_1tuple_3_01Tail_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1rank__any__t.html">rank_any_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">tag struct for <code>MPI_ANY_SOURCE</code>  <a href="structkamping_1_1internal_1_1rank__any__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1rank__null__t.html">rank_null_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">tag struct for <code>MPI_PROC_NULL</code>  <a href="structkamping_1_1internal_1_1rank__null__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkamping_1_1internal_1_1RankDataBuffer.html">RankDataBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates the rank of a PE. This is needed for p2p communication and rooted <code>MPI</code> collectives like <code>MPI_Gather</code>.  <a href="classkamping_1_1internal_1_1RankDataBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkamping_1_1internal_1_1RankDataBuffer_3_01RankType_1_1any_00_01type_01_4.html">RankDataBuffer&lt; RankType::any, type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates the rank of a PE. This is needed for p2p communication and rooted <code>MPI</code> collectives like <code>MPI_Gather</code>.  <a href="classkamping_1_1internal_1_1RankDataBuffer_3_01RankType_1_1any_00_01type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkamping_1_1internal_1_1RankDataBuffer_3_01RankType_1_1null_00_01type_01_4.html">RankDataBuffer&lt; RankType::null, type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates the rank of a PE. This is needed for p2p communication and rooted <code>MPI</code> collectives like <code>MPI_Gather</code>.  <a href="classkamping_1_1internal_1_1RankDataBuffer_3_01RankType_1_1null_00_01type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkamping_1_1internal_1_1RankDataBuffer_3_01RankType_1_1value_00_01type_01_4.html">RankDataBuffer&lt; RankType::value, type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates the rank of a PE. This is needed for p2p communication and rooted <code>MPI</code> collectives like <code>MPI_Gather</code>.  <a href="classkamping_1_1internal_1_1RankDataBuffer_3_01RankType_1_1value_00_01type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1ready__mode__t.html">ready_mode_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">tag for ready send mode  <a href="structkamping_1_1internal_1_1ready__mode__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkamping_1_1internal_1_1ReduceOperation.html">ReduceOperation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps an operation and translates it to a builtin <code>MPI_Op</code> or constructs a custom operation.  <a href="classkamping_1_1internal_1_1ReduceOperation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1ResultCategoryNotUsed.html">ResultCategoryNotUsed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this type if one of the template parameters of <a class="el" href="classkamping_1_1MPIResult.html" title="MPIResult contains the result of a MPI call wrapped by KaMPIng.">MPIResult</a> is not used for a specific wrapped <code>MPI</code> call.  <a href="structkamping_1_1internal_1_1ResultCategoryNotUsed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1SendModeParameter.html">SendModeParameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter object for send_mode encapsulating the send mode compile-time tag.  <a href="structkamping_1_1internal_1_1SendModeParameter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1serialization__support__tag.html">serialization_support_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type to identify serialization support.  <a href="structkamping_1_1internal_1_1serialization__support__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1standard__mode__t.html">standard_mode_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">tag for standard send mode  <a href="structkamping_1_1internal_1_1standard__mode__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1synchronous__mode__t.html">synchronous_mode_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">tag for synchronous send mode  <a href="structkamping_1_1internal_1_1synchronous__mode__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkamping_1_1internal_1_1TagParam.html">TagParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates a message tag.  <a href="classkamping_1_1internal_1_1TagParam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkamping_1_1internal_1_1TagParam_3_01TagType_1_1any_00_01parameter__type___01_4.html">TagParam&lt; TagType::any, parameter_type_ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates a message tag. Specialization if the value is MPI_ANY_TAG.  <a href="classkamping_1_1internal_1_1TagParam_3_01TagType_1_1any_00_01parameter__type___01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkamping_1_1internal_1_1TagParam_3_01TagType_1_1value_00_01parameter__type___01_4.html">TagParam&lt; TagType::value, parameter_type_ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates a message tag. Specialization if an explicit tag value is provided.  <a href="classkamping_1_1internal_1_1TagParam_3_01TagType_1_1value_00_01parameter__type___01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1type__list.html">type_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type for representing a type list.  <a href="structkamping_1_1internal_1_1type__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1unused__tparam.html">unused_tparam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An unused template parameter.  <a href="structkamping_1_1internal_1_1unused__tparam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkamping_1_1internal_1_1UnusedRebindContainer.html">UnusedRebindContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy template for representing the absence of a container to rebind to.  <a href="structkamping_1_1internal_1_1UnusedRebindContainer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkamping_1_1internal_1_1UserOperationPtrWrapper.html">UserOperationPtrWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for a user defined reduction operation based on a function pointer.  <a href="classkamping_1_1internal_1_1UserOperationPtrWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkamping_1_1internal_1_1UserOperationWrapper.html">UserOperationWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for a user defined reduction operation based on a functor object.  <a href="classkamping_1_1internal_1_1UserOperationWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkamping_1_1internal_1_1ValueTypeWrapper.html">ValueTypeWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to get the value type of a non-container type (aka the type itself).  <a href="classkamping_1_1internal_1_1ValueTypeWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkamping_1_1internal_1_1ValueTypeWrapper_3_01true_00_01T_01_4.html">ValueTypeWrapper&lt; true, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to get the value type of a container type.  <a href="classkamping_1_1internal_1_1ValueTypeWrapper_3_01true_00_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a90fb28fc0a6a44eb69a12d869221e421" id="r_a90fb28fc0a6a44eb69a12d869221e421"><td class="memItemLeft" align="right" valign="top"><a id="a90fb28fc0a6a44eb69a12d869221e421" name="a90fb28fc0a6a44eb69a12d869221e421"></a>
<a class="el" href="classkamping_1_1MPIAllocator.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mpi_custom_operation_type</b> = <a class="el" href="classkamping_1_1MPIAllocator.html">void</a> (*)(<a class="el" href="classkamping_1_1MPIAllocator.html">void</a>*, <a class="el" href="classkamping_1_1MPIAllocator.html">void</a>*, <a class="el" href="classkamping_1_1MPIAllocator.html">int</a>*, <a class="el" href="classkamping_1_1MPIAllocator.html">MPI_Datatype</a>*)</td></tr>
<tr class="memdesc:a90fb28fc0a6a44eb69a12d869221e421"><td class="mdescLeft">&#160;</td><td class="mdescRight">type used by user-defined operations passed to <code>MPI_Op_create</code> <br /></td></tr>
<tr class="separator:a90fb28fc0a6a44eb69a12d869221e421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa90eef75e8fcc9e6bd7e2ab7a9b2d4e3" id="r_gaa90eef75e8fcc9e6bd7e2ab7a9b2d4e3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">Arg</a> &gt; </td></tr>
<tr class="memitem:gaa90eef75e8fcc9e6bd7e2ab7a9b2d4e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__kamping__utility.html#gaa90eef75e8fcc9e6bd7e2ab7a9b2d4e3">parameter_type_t</a> = <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="structkamping_1_1internal_1_1ParameterTypeUnwrapping.html">ParameterTypeUnwrapping</a>&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">Arg</a>&gt;::type</td></tr>
<tr class="memdesc:gaa90eef75e8fcc9e6bd7e2ab7a9b2d4e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait for the underlying type of the parameter type of.  <br /></td></tr>
<tr class="separator:gaa90eef75e8fcc9e6bd7e2ab7a9b2d4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga696bc2b8e8463160693104a7de493efb" id="r_ga696bc2b8e8463160693104a7de493efb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__kamping__utility.html#ga0c6ea899ba6946f984708bfc852d44f1">ParameterType</a> parameter_type, typename... Args&gt; </td></tr>
<tr class="memitem:ga696bc2b8e8463160693104a7de493efb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__kamping__utility.html#ga696bc2b8e8463160693104a7de493efb">buffer_type_with_requested_parameter_type</a></td></tr>
<tr class="memdesc:ga696bc2b8e8463160693104a7de493efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of Buffer with requested.  <br /></td></tr>
<tr class="separator:ga696bc2b8e8463160693104a7de493efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d806eff6fb613a2d637e3bb798ec2f" id="r_a57d806eff6fb613a2d637e3bb798ec2f"><td class="memItemLeft" align="right" valign="top"><a id="a57d806eff6fb613a2d637e3bb798ec2f" name="a57d806eff6fb613a2d637e3bb798ec2f"></a>
<a class="el" href="classkamping_1_1MPIAllocator.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RootDataBuffer</b> = <a class="el" href="classkamping_1_1internal_1_1RankDataBuffer.html">RankDataBuffer</a>&lt;<a class="el" href="#a38bae4f1962cbd673975e8b8a74c098aa2063c1608d6e0baf80249c42e2be5804">RankType::value</a>, <a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1a63a9f0ea7bb98050796b649e85481845">ParameterType::root</a>&gt;</td></tr>
<tr class="memdesc:a57d806eff6fb613a2d637e3bb798ec2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for roots;. <br /></td></tr>
<tr class="separator:a57d806eff6fb613a2d637e3bb798ec2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c1b1558240ce44f906eb80e6bbfbbc" id="r_ac9c1b1558240ce44f906eb80e6bbfbbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9c1b1558240ce44f906eb80e6bbfbbc">send_mode_list</a></td></tr>
<tr class="memdesc:ac9c1b1558240ce44f906eb80e6bbfbbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">list of all available send modes  <br /></td></tr>
<tr class="separator:ac9c1b1558240ce44f906eb80e6bbfbbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b63ae79ebe32ba219cd0a5538f978a" id="r_ae6b63ae79ebe32ba219cd0a5538f978a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6b63ae79ebe32ba219cd0a5538f978a">parameter_types_to_ignore_for_result_object</a></td></tr>
<tr class="memdesc:ae6b63ae79ebe32ba219cd0a5538f978a"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of parameter type (entries) which should not be included in the result object.  <br /></td></tr>
<tr class="separator:ae6b63ae79ebe32ba219cd0a5538f978a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aee72027c50fd5cbf052ff6946cf1bbf5" id="r_aee72027c50fd5cbf052ff6946cf1bbf5"><td class="memItemLeft" align="right" valign="top"><a id="aee72027c50fd5cbf052ff6946cf1bbf5" name="aee72027c50fd5cbf052ff6946cf1bbf5"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee72027c50fd5cbf052ff6946cf1bbf5">BufferModifiability</a> { <b>modifiable</b>
, <b>constant</b>
 }</td></tr>
<tr class="memdesc:aee72027c50fd5cbf052ff6946cf1bbf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to specify whether a buffer is modifiable. <br /></td></tr>
<tr class="separator:aee72027c50fd5cbf052ff6946cf1bbf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5c5be2886443fbe345bc5430581727" id="r_aba5c5be2886443fbe345bc5430581727"><td class="memItemLeft" align="right" valign="top"><a id="aba5c5be2886443fbe345bc5430581727" name="aba5c5be2886443fbe345bc5430581727"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba5c5be2886443fbe345bc5430581727">BufferOwnership</a> { <b>owning</b>
, <b>referencing</b>
 }</td></tr>
<tr class="memdesc:aba5c5be2886443fbe345bc5430581727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to specify whether a buffer owns its data. <br /></td></tr>
<tr class="separator:aba5c5be2886443fbe345bc5430581727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c2c3008185fe75ab38a68423877d7e" id="r_a64c2c3008185fe75ab38a68423877d7e"><td class="memItemLeft" align="right" valign="top"><a id="a64c2c3008185fe75ab38a68423877d7e" name="a64c2c3008185fe75ab38a68423877d7e"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64c2c3008185fe75ab38a68423877d7e">BufferAllocation</a> { <b>lib_allocated</b>
, <b>user_allocated</b>
 }</td></tr>
<tr class="memdesc:a64c2c3008185fe75ab38a68423877d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to specify whether a buffer is allocated by the library or the user. <br /></td></tr>
<tr class="separator:a64c2c3008185fe75ab38a68423877d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d60ae867a369e93abb01f4cafe9549" id="r_af5d60ae867a369e93abb01f4cafe9549"><td class="memItemLeft" align="right" valign="top"><a id="af5d60ae867a369e93abb01f4cafe9549" name="af5d60ae867a369e93abb01f4cafe9549"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5d60ae867a369e93abb01f4cafe9549">BufferType</a> { <b>in_buffer</b>
, <b>out_buffer</b>
, <b>in_out_buffer</b>
, <b>ignore</b>
 }</td></tr>
<tr class="memdesc:af5d60ae867a369e93abb01f4cafe9549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to specify whether a buffer is an in buffer of an out buffer. Out buffer will be used to directly write the result to. <br /></td></tr>
<tr class="separator:af5d60ae867a369e93abb01f4cafe9549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c6ea899ba6946f984708bfc852d44f1" id="r_ga0c6ea899ba6946f984708bfc852d44f1"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kamping__utility.html#ga0c6ea899ba6946f984708bfc852d44f1">ParameterType</a> { <br />
&#160;&#160;<a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1af0070ea5bd6cd2e5be902954b501f5f9">ParameterType::send_buf</a>
, <a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1a059c4e80690035e5a83497e4543c8523">ParameterType::recv_buf</a>
, <a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1aae852bad415abe4581126025fda26c18">ParameterType::send_recv_buf</a>
, <a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1ab12aa8c67e9ca7c95071e88cd588358f">ParameterType::recv_counts</a>
, <br />
&#160;&#160;<a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1a2d7719d02e97f913580a07ac37d78288">ParameterType::recv_count</a>
, <a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1a2ef784c69c92ffee0faa6451c6c5168f">ParameterType::recv_displs</a>
, <a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1a06fc72ebb77741a79b40fe26e11d2025">ParameterType::send_counts</a>
, <a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1af536afad9b242a9173755fb4a7babf05">ParameterType::send_count</a>
, <br />
&#160;&#160;<a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1a5cd8c608b1ff4cd171923b88f51c7053">ParameterType::send_displs</a>
, <a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1a20d9c05cfda4d170ea768e3cbf7a93cb">ParameterType::send_recv_count</a>
, <a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1a11d8c28a64490a987612f2332502467f">ParameterType::op</a>
, <a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1a36cd38f49b9afa08222c0dc9ebfe35eb">ParameterType::source</a>
, <br />
&#160;&#160;<a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1a6990a54322d9232390a784c5c9247dd6">ParameterType::destination</a>
, <a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1a9acb44549b41563697bb490144ec6258">ParameterType::status</a>
, <a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1acccb484e3a7978e609c6d8725c8c8c09">ParameterType::statuses</a>
, <a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1a10573b873d2fa5a365d558a45e328e47">ParameterType::request</a>
, <br />
&#160;&#160;<a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1a63a9f0ea7bb98050796b649e85481845">ParameterType::root</a>
, <a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1ae4d23e841d8e8804190027bce3180fa5">ParameterType::tag</a>
, <a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1adb9cd8a93331c1d392dfa20cbc625a5f">ParameterType::send_tag</a>
, <a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1aa54c62fccc0ba713162ca2f29cf8281a">ParameterType::recv_tag</a>
, <br />
&#160;&#160;<a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1a390e337255c39617e74ffe2cff14f79a">ParameterType::send_mode</a>
, <a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1ad6d3a017f4450a531800f64154ef3ffb">ParameterType::values_on_rank_0</a>
, <a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1ab55f796cd7c01da784e597481890e01b">ParameterType::send_type</a>
, <a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1a3dd80893478c5fbd9e1507bca9358131">ParameterType::recv_type</a>
, <br />
&#160;&#160;<a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1a831e0f5546c437f7922dcd2f58b75b12">ParameterType::send_recv_type</a>
<br />
 }</td></tr>
<tr class="memdesc:ga0c6ea899ba6946f984708bfc852d44f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each input parameter to one of the <code>MPI</code> calls wrapped by KaMPIng needs to has one of the following tags.  <a href="group__kamping__utility.html#ga0c6ea899ba6946f984708bfc852d44f1">More...</a><br /></td></tr>
<tr class="separator:ga0c6ea899ba6946f984708bfc852d44f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38bae4f1962cbd673975e8b8a74c098a" id="r_a38bae4f1962cbd673975e8b8a74c098a"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38bae4f1962cbd673975e8b8a74c098a">RankType</a> { <a class="el" href="#a38bae4f1962cbd673975e8b8a74c098aa2063c1608d6e0baf80249c42e2be5804">value</a>
, <a class="el" href="#a38bae4f1962cbd673975e8b8a74c098aa100b8cad7cf2a56f6df78f171f97a1ec">any</a>
, <a class="el" href="#a38bae4f1962cbd673975e8b8a74c098aa37a6259cc0c1dae299a7866489dff0bd">null</a>
 }</td></tr>
<tr class="memdesc:a38bae4f1962cbd673975e8b8a74c098a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicator if a rank parameter holds and actual value or <code>MPI_ANY_SOURCE</code> or <code>MPI_PROC_NULL</code>.  <a href="#a38bae4f1962cbd673975e8b8a74c098a">More...</a><br /></td></tr>
<tr class="separator:a38bae4f1962cbd673975e8b8a74c098a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287496ae13baab7eb561edb4c4948a43" id="r_a287496ae13baab7eb561edb4c4948a43"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a287496ae13baab7eb561edb4c4948a43">TagType</a> { <a class="el" href="#a287496ae13baab7eb561edb4c4948a43a2063c1608d6e0baf80249c42e2be5804">value</a>
, <a class="el" href="#a287496ae13baab7eb561edb4c4948a43a100b8cad7cf2a56f6df78f171f97a1ec">any</a>
 }</td></tr>
<tr class="memdesc:a287496ae13baab7eb561edb4c4948a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible types of tag.  <a href="#a287496ae13baab7eb561edb4c4948a43">More...</a><br /></td></tr>
<tr class="separator:a287496ae13baab7eb561edb4c4948a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a54f1f757f74353f0f5d88262990f0dca" id="r_a54f1f757f74353f0f5d88262990f0dca"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">RecvCounts</a> , <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">RecvDispls</a> &gt; </td></tr>
<tr class="memitem:a54f1f757f74353f0f5d88262990f0dca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a54f1f757f74353f0f5d88262990f0dca">compute_required_recv_buf_size_in_vectorized_communication</a> (<a class="el" href="classkamping_1_1MPIAllocator.html">RecvCounts</a> <a class="el" href="classkamping_1_1MPIAllocator.html">const</a> &amp;<a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1ab12aa8c67e9ca7c95071e88cd588358f">recv_counts</a>, <a class="el" href="classkamping_1_1MPIAllocator.html">RecvDispls</a> <a class="el" href="classkamping_1_1MPIAllocator.html">const</a> &amp;<a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1a2ef784c69c92ffee0faa6451c6c5168f">recv_displs</a>, <a class="el" href="classkamping_1_1MPIAllocator.html">size_t</a> <a class="el" href="classkamping_1_1MPIAllocator.html">comm_size</a>)</td></tr>
<tr class="memdesc:a54f1f757f74353f0f5d88262990f0dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the required size of the recv buffer in vectorized communication (i.e. <code>MPI</code> operation that take a receive displacements). If recv displs are provided by the user the required size is the sum of the last entries of the recv_counts and the recv_displs buffers. Otherwise we have to compute the elementwise maximum of both buffers to obtain a minimum required recv buf size.  <br /></td></tr>
<tr class="separator:a54f1f757f74353f0f5d88262990f0dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57801ac8835484dab49470ef4a3440b" id="r_ab57801ac8835484dab49470ef4a3440b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">send_value_type</a> , <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">recv_value_type</a> , <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1a059c4e80690035e5a83497e4543c8523">recv_buf</a> , typename... Args&gt; </td></tr>
<tr class="memitem:ab57801ac8835484dab49470ef4a3440b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab57801ac8835484dab49470ef4a3440b">determine_mpi_datatypes</a> (<a class="el" href="classkamping_1_1MPIAllocator.html">Args</a> &amp;... <a class="el" href="classkamping_1_1MPIAllocator.html">args</a>)</td></tr>
<tr class="memdesc:ab57801ac8835484dab49470ef4a3440b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce the MPI_Datatype to use on the send and recv side. If <a class="el" href="group__kamping__named__parameters.html#gab9a147682a19a084e087063a8080eca0">kamping::send_type()</a> is given, the <code>MPI_Datatype</code> wrapped inside will be used as send_type. Otherwise, the <code>MPI_datatype</code> is derived automatically based on send_buf's underlying <code>value_type</code>.  <br /></td></tr>
<tr class="separator:ab57801ac8835484dab49470ef4a3440b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ddd5be97dce9b064c940f88ba734c98" id="r_a1ddd5be97dce9b064c940f88ba734c98"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">send_or_send_recv_value_type</a> , <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">recv_or_send_recv_buf</a> , typename... Args&gt; </td></tr>
<tr class="memitem:a1ddd5be97dce9b064c940f88ba734c98"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1ddd5be97dce9b064c940f88ba734c98">determine_mpi_send_recv_datatype</a> (<a class="el" href="classkamping_1_1MPIAllocator.html">Args</a> &amp;... <a class="el" href="classkamping_1_1MPIAllocator.html">args</a>) -&gt; <a class="el" href="classkamping_1_1MPIAllocator.html">decltype</a>(<a class="el" href="group__kamping__utility.html#ga509c4c4989fa3924469e713dddb66c02">internal::select_parameter_type_or_default</a>&lt; <a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1a831e0f5546c437f7922dcd2f58b75b12">internal::ParameterType::send_recv_type</a>, <a class="el" href="classkamping_1_1MPIAllocator.html">decltype</a>(<a class="el" href="group__kamping__named__parameters.html#ga4c7c40e498c68c12a46646e19865c853">kamping::send_recv_type_out</a>())&gt;(std::make_tuple(), args...) .construct_buffer_or_rebind())</td></tr>
<tr class="memdesc:a1ddd5be97dce9b064c940f88ba734c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce the MPI_Datatype to use as send_recv_type in a collective operation which accepts only one parameter of MPI_Datatype instead of (possibly) distinct send and recv types. If <a class="el" href="group__kamping__named__parameters.html#ga76c1572157e7012980fefec17534c085">kamping::send_recv_type()</a> is given, the <code>MPI_Datatype</code> wrapped inside will be used as send_recv_type. Otherwise, the <code>MPI_datatype</code> is derived automatically based on send_buf's underlying <code>value_type</code>.  <br /></td></tr>
<tr class="separator:a1ddd5be97dce9b064c940f88ba734c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02cfe2c4e09251e5a488973dde68c13" id="r_af02cfe2c4e09251e5a488973dde68c13"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">TParameterType</a> , <a class="el" href="classkamping_1_1MPIAllocator.html">TParameterType</a> parameter_type, <a class="el" href="#aee72027c50fd5cbf052ff6946cf1bbf5">BufferModifiability</a> modifiability, <a class="el" href="#af5d60ae867a369e93abb01f4cafe9549">BufferType</a> buffer_type, <a class="el" href="group__kamping__mpi__utility.html#ga76ff5c12e22ce699d271eddc97bc50f7">BufferResizePolicy</a> buffer_resize_policy, <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">ValueType</a>  = default_value_type_tag, <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">Data</a> &gt; </td></tr>
<tr class="memitem:af02cfe2c4e09251e5a488973dde68c13"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af02cfe2c4e09251e5a488973dde68c13">make_data_buffer</a> (<a class="el" href="classkamping_1_1MPIAllocator.html">Data</a> &amp;&amp;data)</td></tr>
<tr class="memdesc:af02cfe2c4e09251e5a488973dde68c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a user allocated <a class="el" href="classkamping_1_1internal_1_1DataBuffer.html" title="Data buffer used for named parameters.">DataBuffer</a> containing the supplied data (a container or a single element)  <br /></td></tr>
<tr class="separator:af02cfe2c4e09251e5a488973dde68c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873a595ca729ddb13bbc9b66d1124373" id="r_a873a595ca729ddb13bbc9b66d1124373"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">TParameterType</a> , <a class="el" href="classkamping_1_1MPIAllocator.html">TParameterType</a> parameter_type, <a class="el" href="#aee72027c50fd5cbf052ff6946cf1bbf5">BufferModifiability</a> modifiability, <a class="el" href="#af5d60ae867a369e93abb01f4cafe9549">BufferType</a> buffer_type, <a class="el" href="group__kamping__mpi__utility.html#ga76ff5c12e22ce699d271eddc97bc50f7">BufferResizePolicy</a> buffer_resize_policy, <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">ValueType</a>  = default_value_type_tag, <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">Data</a> &gt; </td></tr>
<tr class="memitem:a873a595ca729ddb13bbc9b66d1124373"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a873a595ca729ddb13bbc9b66d1124373">make_data_buffer</a> (<a class="el" href="structkamping_1_1AllocNewT.html">AllocNewT</a>&lt; <a class="el" href="classkamping_1_1MPIAllocator.html">Data</a> &gt;)</td></tr>
<tr class="memdesc:a873a595ca729ddb13bbc9b66d1124373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a library allocated <a class="el" href="classkamping_1_1internal_1_1DataBuffer.html" title="Data buffer used for named parameters.">DataBuffer</a> with the given container or single data type.  <br /></td></tr>
<tr class="separator:a873a595ca729ddb13bbc9b66d1124373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b28ebe97f38023ad60b0b8302fce56" id="r_a19b28ebe97f38023ad60b0b8302fce56"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">TParameterType</a> , <a class="el" href="group__kamping__utility.html#ga0c6ea899ba6946f984708bfc852d44f1">ParameterType</a> parameter_type, <a class="el" href="#aee72027c50fd5cbf052ff6946cf1bbf5">BufferModifiability</a> modifiability, <a class="el" href="#af5d60ae867a369e93abb01f4cafe9549">BufferType</a> buffer_type, <a class="el" href="group__kamping__mpi__utility.html#ga76ff5c12e22ce699d271eddc97bc50f7">BufferResizePolicy</a> buffer_resize_policy, <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">ValueType</a>  = default_value_type_tag, <a class="el" href="classkamping_1_1MPIAllocator.html">template</a>&lt; typename... &gt; <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> Data&gt; </td></tr>
<tr class="memitem:a19b28ebe97f38023ad60b0b8302fce56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a19b28ebe97f38023ad60b0b8302fce56">make_data_buffer</a> (<a class="el" href="structkamping_1_1AllocNewUsingT.html">AllocNewUsingT</a>&lt; <a class="el" href="classkamping_1_1MPIAllocator.html">Data</a> &gt;)</td></tr>
<tr class="memdesc:a19b28ebe97f38023ad60b0b8302fce56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a library allocated <a class="el" href="classkamping_1_1internal_1_1DataBuffer.html" title="Data buffer used for named parameters.">DataBuffer</a> by instantiating the given container template with the given value type.  <br /></td></tr>
<tr class="separator:a19b28ebe97f38023ad60b0b8302fce56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397c69ed1325d75a0f0af9b174e39a1b" id="r_a397c69ed1325d75a0f0af9b174e39a1b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">NeighborhoodRange</a> &gt; </td></tr>
<tr class="memitem:a397c69ed1325d75a0f0af9b174e39a1b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a397c69ed1325d75a0f0af9b174e39a1b">are_neighborhoods_weighted</a> ()</td></tr>
<tr class="memdesc:a397c69ed1325d75a0f0af9b174e39a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a given range of neighbors is weighted or not at compile time, i.e., whether the neighborhood only consists of ranks or of (rank, weight) pairs.  <br /></td></tr>
<tr class="separator:a397c69ed1325d75a0f0af9b174e39a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a024a8064235f280947475d671a9443" id="r_a3a024a8064235f280947475d671a9443"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">RankDataBufferClass</a> , <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">Comm</a> &gt; </td></tr>
<tr class="memitem:a3a024a8064235f280947475d671a9443"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3a024a8064235f280947475d671a9443">is_valid_rank_in_comm</a> (<a class="el" href="classkamping_1_1MPIAllocator.html">RankDataBufferClass</a> <a class="el" href="classkamping_1_1MPIAllocator.html">const</a> &amp;<a class="el" href="classkamping_1_1MPIAllocator.html">rank_data_buffer</a>, <a class="el" href="classkamping_1_1MPIAllocator.html">Comm</a> <a class="el" href="classkamping_1_1MPIAllocator.html">const</a> &amp;<a class="el" href="classkamping_1_1MPIAllocator.html">comm</a>, <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a> <a class="el" href="classkamping_1_1MPIAllocator.html">const</a> <a class="el" href="classkamping_1_1MPIAllocator.html">allow_null</a>=<a class="el" href="classkamping_1_1MPIAllocator.html">false</a>, <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a> <a class="el" href="classkamping_1_1MPIAllocator.html">const</a> <a class="el" href="classkamping_1_1MPIAllocator.html">allow_any</a>=<a class="el" href="classkamping_1_1MPIAllocator.html">false</a>)</td></tr>
<tr class="memdesc:a3a024a8064235f280947475d671a9443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a <a class="el" href="classkamping_1_1internal_1_1RankDataBuffer.html" title="Encapsulates the rank of a PE. This is needed for p2p communication and rooted MPI collectives like M...">RankDataBuffer</a> contains a valid rank in the given communicator.  <br /></td></tr>
<tr class="separator:a3a024a8064235f280947475d671a9443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593049f3f20541d6fd688d79be48236d" id="r_a593049f3f20541d6fd688d79be48236d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> T , <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">F</a> , size_t... Is&gt; </td></tr>
<tr class="memitem:a593049f3f20541d6fd688d79be48236d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a593049f3f20541d6fd688d79be48236d">for_each_tuple_field</a> (T &amp;&amp;<a class="el" href="classkamping_1_1MPIAllocator.html">t</a>, <a class="el" href="classkamping_1_1MPIAllocator.html">F</a> &amp;&amp;f, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="memdesc:a593049f3f20541d6fd688d79be48236d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies functor <code>f</code> to each field of the tuple with an index in index sequence <code>Is</code>.  <br /></td></tr>
<tr class="separator:a593049f3f20541d6fd688d79be48236d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae552657e8f8cd6538dffa3858a7934bb" id="r_ae552657e8f8cd6538dffa3858a7934bb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> T , <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">F</a> &gt; </td></tr>
<tr class="memitem:ae552657e8f8cd6538dffa3858a7934bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae552657e8f8cd6538dffa3858a7934bb">for_each_tuple_field</a> (T &amp;<a class="el" href="classkamping_1_1MPIAllocator.html">t</a>, <a class="el" href="classkamping_1_1MPIAllocator.html">F</a> &amp;&amp;f)</td></tr>
<tr class="memdesc:ae552657e8f8cd6538dffa3858a7934bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies functor <code>f</code> to each field of the tuple <code>t</code>.  <br /></td></tr>
<tr class="separator:ae552657e8f8cd6538dffa3858a7934bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62afac32672786fd0541cca76e64c8bf" id="r_a62afac32672786fd0541cca76e64c8bf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> T , <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">F</a> &gt; </td></tr>
<tr class="memitem:a62afac32672786fd0541cca76e64c8bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a62afac32672786fd0541cca76e64c8bf">for_each_field</a> (T &amp;<a class="el" href="classkamping_1_1MPIAllocator.html">t</a>, <a class="el" href="classkamping_1_1MPIAllocator.html">F</a> &amp;&amp;f)</td></tr>
<tr class="memdesc:a62afac32672786fd0541cca76e64c8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies functor <code>f</code> to each field of the tuple-like type <code>t</code>. This works for <code>std::pair</code> and <code>std::tuple</code>. If KaMPIng's reflection support is enabled, this also works with types that are reflectable with <a href="https://github.com/boostorg/pfr">pfr</a>.  <br /></td></tr>
<tr class="separator:a62afac32672786fd0541cca76e64c8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace93d4e5a4b4c7c054604ccd31d42906" id="r_ace93d4e5a4b4c7c054604ccd31d42906"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">Functor</a> &gt; </td></tr>
<tr class="memitem:ace93d4e5a4b4c7c054604ccd31d42906"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ace93d4e5a4b4c7c054604ccd31d42906">with_operation_functor</a> (<a class="el" href="classkamping_1_1MPIAllocator.html">MPI_Op</a> <a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1a11d8c28a64490a987612f2332502467f">op</a>, <a class="el" href="classkamping_1_1MPIAllocator.html">Functor</a> &amp;&amp;<a class="el" href="classkamping_1_1MPIAllocator.html">func</a>)</td></tr>
<tr class="memdesc:ace93d4e5a4b4c7c054604ccd31d42906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that maps an <code>MPI_Op</code> to the matching functor from <code><a class="el" href="namespacekamping_1_1ops.html" title="this namespace contains all builtin operations supported by MPI.">kamping::ops</a></code>. In case no function maps, the functor is called with <code>kamping::ops::null&lt;&gt;{}</code>.  <br /></td></tr>
<tr class="separator:ace93d4e5a4b4c7c054604ccd31d42906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada625152fce9d38c862b1f44929cfa95" id="r_ada625152fce9d38c862b1f44929cfa95"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__kamping__utility.html#ga0c6ea899ba6946f984708bfc852d44f1">internal::ParameterType</a> ptype, typename... Buffers&gt; </td></tr>
<tr class="memitem:ada625152fce9d38c862b1f44929cfa95"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ada625152fce9d38c862b1f44929cfa95">retrieve_buffer</a> (std::tuple&lt; Buffers... &gt; &amp;<a class="el" href="classkamping_1_1MPIAllocator.html">buffers</a>)</td></tr>
<tr class="memdesc:ada625152fce9d38c862b1f44929cfa95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the buffer with requested ParameterType from the std::tuple containg all buffers.  <br /></td></tr>
<tr class="separator:ada625152fce9d38c862b1f44929cfa95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68357b6c4d61a873b4446165f3d6265c" id="r_a68357b6c4d61a873b4446165f3d6265c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">ParameterTypeTuple</a> , typename... Buffers, std::size_t... i&gt; </td></tr>
<tr class="memitem:a68357b6c4d61a873b4446165f3d6265c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a68357b6c4d61a873b4446165f3d6265c">construct_buffer_tuple_impl</a> (std::tuple&lt; Buffers... &gt; &amp;<a class="el" href="classkamping_1_1MPIAllocator.html">buffers</a>, std::index_sequence&lt; i... &gt;)</td></tr>
<tr class="memdesc:a68357b6c4d61a873b4446165f3d6265c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct tuple containing all buffers specified in.  <br /></td></tr>
<tr class="separator:a68357b6c4d61a873b4446165f3d6265c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef350125bc9972442350922cdcd6c8c" id="r_afef350125bc9972442350922cdcd6c8c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">ParameterTypeTuple</a> , typename... Buffers&gt; </td></tr>
<tr class="memitem:afef350125bc9972442350922cdcd6c8c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afef350125bc9972442350922cdcd6c8c">construct_buffer_tuple</a> (<a class="el" href="classkamping_1_1MPIAllocator.html">Buffers</a> &amp;&amp;... <a class="el" href="classkamping_1_1MPIAllocator.html">buffers</a>)</td></tr>
<tr class="memdesc:afef350125bc9972442350922cdcd6c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct tuple containing all buffers specified in.  <br /></td></tr>
<tr class="separator:afef350125bc9972442350922cdcd6c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42b1831706d6b57a786a71deb56e9398" id="r_ga42b1831706d6b57a786a71deb56e9398"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> T , <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">U</a> &gt; </td></tr>
<tr class="memitem:ga42b1831706d6b57a786a71deb56e9398"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__kamping__utility.html#ga42b1831706d6b57a786a71deb56e9398">has_same_parameter_type</a> ()</td></tr>
<tr class="memdesc:ga42b1831706d6b57a786a71deb56e9398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether two objects have the same parameter type.  <br /></td></tr>
<tr class="separator:ga42b1831706d6b57a786a71deb56e9398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab17a7f10b08f95d94c7375c91f1a0d7a" id="r_gab17a7f10b08f95d94c7375c91f1a0d7a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">ParameterTypeConstant</a> , <a class="el" href="classkamping_1_1MPIAllocator.html">size_t</a> Index&gt; </td></tr>
<tr class="memitem:gab17a7f10b08f95d94c7375c91f1a0d7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__kamping__utility.html#gab17a7f10b08f95d94c7375c91f1a0d7a">find_pos</a> ()</td></tr>
<tr class="memdesc:gab17a7f10b08f95d94c7375c91f1a0d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base case if there are no parameters: always returns max index indicating that the parameter was not found.  <br /></td></tr>
<tr class="separator:gab17a7f10b08f95d94c7375c91f1a0d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3887be12af5527b585d0a0fd306ff72" id="r_gac3887be12af5527b585d0a0fd306ff72"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">ParameterTypeConstant</a> , <a class="el" href="classkamping_1_1MPIAllocator.html">size_t</a> Index, <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">Arg</a> &gt; </td></tr>
<tr class="memitem:gac3887be12af5527b585d0a0fd306ff72"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__kamping__utility.html#gac3887be12af5527b585d0a0fd306ff72">find_pos</a> ()</td></tr>
<tr class="memdesc:gac3887be12af5527b585d0a0fd306ff72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Index parameter if the parameter type of Arg matches the requested parameter type. If not, this fails to compile.  <br /></td></tr>
<tr class="separator:gac3887be12af5527b585d0a0fd306ff72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab667fd92f3be1dbb428cbb1a024896c2" id="r_gab667fd92f3be1dbb428cbb1a024896c2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">ParameterTypeConstant</a> , <a class="el" href="classkamping_1_1MPIAllocator.html">size_t</a> Index, <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">Arg</a> , <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">Arg2</a> , typename... Args&gt; </td></tr>
<tr class="memitem:gab667fd92f3be1dbb428cbb1a024896c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__kamping__utility.html#gab667fd92f3be1dbb428cbb1a024896c2">find_pos</a> ()</td></tr>
<tr class="memdesc:gab667fd92f3be1dbb428cbb1a024896c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns position of first argument in Args with Trait trait.  <br /></td></tr>
<tr class="separator:gab667fd92f3be1dbb428cbb1a024896c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac97d501b7c18b90c0686516db141f6a9" id="r_gac97d501b7c18b90c0686516db141f6a9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">ParameterTypeConstant</a> , typename... Args&gt; </td></tr>
<tr class="memitem:gac97d501b7c18b90c0686516db141f6a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__kamping__utility.html#gac97d501b7c18b90c0686516db141f6a9">select_parameter_type</a> (<a class="el" href="classkamping_1_1MPIAllocator.html">Args</a> &amp;... <a class="el" href="classkamping_1_1MPIAllocator.html">args</a>)</td></tr>
<tr class="memdesc:gac97d501b7c18b90c0686516db141f6a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns parameter with requested parameter type.  <br /></td></tr>
<tr class="separator:gac97d501b7c18b90c0686516db141f6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac957d7eda07f96f171fabae7b823c478" id="r_gac957d7eda07f96f171fabae7b823c478"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__kamping__utility.html#ga0c6ea899ba6946f984708bfc852d44f1">ParameterType</a> parameter_type, typename... Args&gt; </td></tr>
<tr class="memitem:gac957d7eda07f96f171fabae7b823c478"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__kamping__utility.html#gac957d7eda07f96f171fabae7b823c478">select_parameter_type_in_tuple</a> (std::tuple&lt; Args... &gt; &amp;<a class="el" href="classkamping_1_1MPIAllocator.html">tuple</a>)</td></tr>
<tr class="memdesc:gac957d7eda07f96f171fabae7b823c478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns parameter with requested parameter type.  <br /></td></tr>
<tr class="separator:gac957d7eda07f96f171fabae7b823c478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf88a381f2fc75e923eb9398b7a92e94" id="r_gacf88a381f2fc75e923eb9398b7a92e94"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__kamping__utility.html#ga0c6ea899ba6946f984708bfc852d44f1">ParameterType</a> parameter_type, typename... Args&gt; </td></tr>
<tr class="memitem:gacf88a381f2fc75e923eb9398b7a92e94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a> <a class="el" href="classkamping_1_1MPIAllocator.html">const</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__kamping__utility.html#gacf88a381f2fc75e923eb9398b7a92e94">select_parameter_type_in_tuple</a> (std::tuple&lt; Args... &gt; <a class="el" href="classkamping_1_1MPIAllocator.html">const</a> &amp;<a class="el" href="classkamping_1_1MPIAllocator.html">tuple</a>)</td></tr>
<tr class="memdesc:gacf88a381f2fc75e923eb9398b7a92e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns parameter with requested parameter type.  <br /></td></tr>
<tr class="separator:gacf88a381f2fc75e923eb9398b7a92e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ebf92c5a30b0050287bb46dd9cc9ff6" id="r_ga9ebf92c5a30b0050287bb46dd9cc9ff6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">ParameterTypeConstant</a> , typename... Args&gt; </td></tr>
<tr class="memitem:ga9ebf92c5a30b0050287bb46dd9cc9ff6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__kamping__utility.html#ga9ebf92c5a30b0050287bb46dd9cc9ff6">has_parameter_type</a> ()</td></tr>
<tr class="memdesc:ga9ebf92c5a30b0050287bb46dd9cc9ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if parameter with requested parameter type exists.  <br /></td></tr>
<tr class="separator:ga9ebf92c5a30b0050287bb46dd9cc9ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f33fad47fe0436eaab29a8cc59ec55d" id="r_ga0f33fad47fe0436eaab29a8cc59ec55d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__kamping__utility.html#ga0c6ea899ba6946f984708bfc852d44f1">ParameterType</a> parameter_type, typename... Args&gt; </td></tr>
<tr class="memitem:ga0f33fad47fe0436eaab29a8cc59ec55d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__kamping__utility.html#ga0f33fad47fe0436eaab29a8cc59ec55d">has_parameter_type_in_tuple_impl</a> (<a class="el" href="structkamping_1_1internal_1_1has__parameter__helper.html">has_parameter_helper</a>&lt; std::tuple&lt; Args... &gt; &gt;)</td></tr>
<tr class="memdesc:ga0f33fad47fe0436eaab29a8cc59ec55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if parameter with requested parameter type exists. Wrapper using the functionality from <a class="el" href="group__kamping__utility.html#ga9ebf92c5a30b0050287bb46dd9cc9ff6">kamping::internal::has_parameter_type()</a> disassembling a std::tuple passed as parameter.  <br /></td></tr>
<tr class="separator:ga0f33fad47fe0436eaab29a8cc59ec55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54334a3fee212d26c0ac120a64e957ad" id="r_ga54334a3fee212d26c0ac120a64e957ad"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__kamping__utility.html#ga0c6ea899ba6946f984708bfc852d44f1">ParameterType</a> parameter_type, <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">Tuple</a> &gt; </td></tr>
<tr class="memitem:ga54334a3fee212d26c0ac120a64e957ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__kamping__utility.html#ga54334a3fee212d26c0ac120a64e957ad">has_parameter_type_in_tuple</a> ()</td></tr>
<tr class="memdesc:ga54334a3fee212d26c0ac120a64e957ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if parameter with requested parameter type exists.  <br /></td></tr>
<tr class="separator:ga54334a3fee212d26c0ac120a64e957ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga509c4c4989fa3924469e713dddb66c02" id="r_ga509c4c4989fa3924469e713dddb66c02"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">ParameterTypeConstant</a> , <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">DefaultParameterType</a> , typename... DefaultArguments, typename... Args&gt; </td></tr>
<tr class="memitem:ga509c4c4989fa3924469e713dddb66c02"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">decltype</a>(<a class="el" href="classkamping_1_1MPIAllocator.html">auto</a>)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__kamping__utility.html#ga509c4c4989fa3924469e713dddb66c02">select_parameter_type_or_default</a> (std::tuple&lt; DefaultArguments... &gt; <a class="el" href="classkamping_1_1MPIAllocator.html">default_arguments</a>, <a class="el" href="classkamping_1_1MPIAllocator.html">Args</a> &amp;... <a class="el" href="classkamping_1_1MPIAllocator.html">args</a>)</td></tr>
<tr class="memdesc:ga509c4c4989fa3924469e713dddb66c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if parameter with requested parameter type exists, if not constructs a default value.  <br /></td></tr>
<tr class="separator:ga509c4c4989fa3924469e713dddb66c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafabb03b2238196c2e5eeefad079440e" id="r_aafabb03b2238196c2e5eeefad079440e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">send_value_type</a> , typename... Args&gt; </td></tr>
<tr class="memitem:aafabb03b2238196c2e5eeefad079440e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aafabb03b2238196c2e5eeefad079440e">determine_mpi_send_datatype</a> (<a class="el" href="classkamping_1_1MPIAllocator.html">Args</a> &amp;... <a class="el" href="classkamping_1_1MPIAllocator.html">args</a>) -&gt; <a class="el" href="classkamping_1_1MPIAllocator.html">decltype</a>(<a class="el" href="group__kamping__utility.html#ga509c4c4989fa3924469e713dddb66c02">internal::select_parameter_type_or_default</a>&lt; <a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1ab55f796cd7c01da784e597481890e01b">internal::ParameterType::send_type</a>, <a class="el" href="classkamping_1_1MPIAllocator.html">decltype</a>(<a class="el" href="group__kamping__named__parameters.html#ga4f730152723b846b178035dd0ddfbc39">kamping::send_type_out</a>())&gt;(std::make_tuple(), args...) .construct_buffer_or_rebind())</td></tr>
<tr class="memdesc:aafabb03b2238196c2e5eeefad079440e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce the MPI_Datatype to use as send_type in a p2p send operation.If <a class="el" href="group__kamping__named__parameters.html#gab9a147682a19a084e087063a8080eca0">kamping::send_type()</a> is given, the <code>MPI_Datatype</code> wrapped inside will be used as send_type. Otherwise, the <code>MPI_datatype</code> is derived automatically based on send_buf's underlying <code>value_type</code>.  <br /></td></tr>
<tr class="separator:aafabb03b2238196c2e5eeefad079440e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5785792eadf68f880a126ca6506a94" id="r_a9d5785792eadf68f880a126ca6506a94"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">recv_value_type</a> , <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1a059c4e80690035e5a83497e4543c8523">recv_buf</a> , typename... Args&gt; </td></tr>
<tr class="memitem:a9d5785792eadf68f880a126ca6506a94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9d5785792eadf68f880a126ca6506a94">determine_mpi_recv_datatype</a> (<a class="el" href="classkamping_1_1MPIAllocator.html">Args</a> &amp;... <a class="el" href="classkamping_1_1MPIAllocator.html">args</a>) -&gt; <a class="el" href="classkamping_1_1MPIAllocator.html">decltype</a>(<a class="el" href="group__kamping__utility.html#ga509c4c4989fa3924469e713dddb66c02">internal::select_parameter_type_or_default</a>&lt; <a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1a3dd80893478c5fbd9e1507bca9358131">internal::ParameterType::recv_type</a>, <a class="el" href="classkamping_1_1MPIAllocator.html">decltype</a>(<a class="el" href="group__kamping__named__parameters.html#ga5bb423bbc6d83e274aec7622104db943">kamping::recv_type_out</a>())&gt;(std::make_tuple(), args...) .construct_buffer_or_rebind())</td></tr>
<tr class="memdesc:a9d5785792eadf68f880a126ca6506a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce the MPI_Datatype to use as recv_type in a p2p recv operation.If <a class="el" href="group__kamping__named__parameters.html#gab151f99be902ed709832ae6e8be19d87">kamping::recv_type()</a> is given, the <code>MPI_Datatype</code> wrapped inside will be used as recv_type. Otherwise, the <code>MPI_datatype</code> is derived automatically based on recv_buf's underlying <code>value_type</code>.  <br /></td></tr>
<tr class="separator:a9d5785792eadf68f880a126ca6506a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4c25930d855a9e66c3b2ca061cbe2d" id="r_a7a4c25930d855a9e66c3b2ca061cbe2d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__kamping__utility.html#ga0c6ea899ba6946f984708bfc852d44f1">ParameterType</a> parameter_type, <a class="el" href="#aee72027c50fd5cbf052ff6946cf1bbf5">BufferModifiability</a> modifiability, <a class="el" href="#af5d60ae867a369e93abb01f4cafe9549">BufferType</a> buffer_type, <a class="el" href="group__kamping__mpi__utility.html#ga76ff5c12e22ce699d271eddc97bc50f7">BufferResizePolicy</a> buffer_resize_policy, <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">ValueType</a>  = default_value_type_tag, <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">Data</a> &gt; </td></tr>
<tr class="memitem:a7a4c25930d855a9e66c3b2ca061cbe2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7a4c25930d855a9e66c3b2ca061cbe2d">make_data_buffer_builder</a> (<a class="el" href="classkamping_1_1MPIAllocator.html">Data</a> &amp;&amp;data)</td></tr>
<tr class="memdesc:a7a4c25930d855a9e66c3b2ca061cbe2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method for constructing a <a class="el" href="structkamping_1_1internal_1_1DataBufferBuilder.html">DataBufferBuilder</a> from the given Container <code>Data</code>.  <br /></td></tr>
<tr class="separator:a7a4c25930d855a9e66c3b2ca061cbe2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad254b837335d9568056f1a9226ea7371" id="r_ad254b837335d9568056f1a9226ea7371"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__kamping__utility.html#ga0c6ea899ba6946f984708bfc852d44f1">ParameterType</a> parameter_type, <a class="el" href="#aee72027c50fd5cbf052ff6946cf1bbf5">BufferModifiability</a> modifiability, <a class="el" href="#af5d60ae867a369e93abb01f4cafe9549">BufferType</a> buffer_type, <a class="el" href="group__kamping__mpi__utility.html#ga76ff5c12e22ce699d271eddc97bc50f7">BufferResizePolicy</a> buffer_resize_policy, <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">Data</a> &gt; </td></tr>
<tr class="memitem:ad254b837335d9568056f1a9226ea7371"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad254b837335d9568056f1a9226ea7371">make_data_buffer_builder</a> (std::initializer_list&lt; <a class="el" href="classkamping_1_1MPIAllocator.html">Data</a> &gt; data)</td></tr>
<tr class="memdesc:ad254b837335d9568056f1a9226ea7371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method for constructing a <a class="el" href="structkamping_1_1internal_1_1DataBufferBuilder.html">DataBufferBuilder</a> from an <code>std::initializer_list</code>.  <br /></td></tr>
<tr class="separator:ad254b837335d9568056f1a9226ea7371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fa618ff3ea408e48bc2184a9d16935" id="r_ab4fa618ff3ea408e48bc2184a9d16935"><td class="memTemplParams" colspan="2"><a id="ab4fa618ff3ea408e48bc2184a9d16935" name="ab4fa618ff3ea408e48bc2184a9d16935"></a>
template&lt;<a class="el" href="group__kamping__utility.html#ga0c6ea899ba6946f984708bfc852d44f1">ParameterType</a> parameter_type, <a class="el" href="#aee72027c50fd5cbf052ff6946cf1bbf5">BufferModifiability</a> modifiability, <a class="el" href="#af5d60ae867a369e93abb01f4cafe9549">BufferType</a> buffer_type, <a class="el" href="group__kamping__mpi__utility.html#ga76ff5c12e22ce699d271eddc97bc50f7">BufferResizePolicy</a> buffer_resize_policy, <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">ValueType</a>  = default_value_type_tag, <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">Data</a> &gt; </td></tr>
<tr class="memitem:ab4fa618ff3ea408e48bc2184a9d16935"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_data_buffer_builder</b> (<a class="el" href="structkamping_1_1AllocNewT.html">AllocNewT</a>&lt; <a class="el" href="classkamping_1_1MPIAllocator.html">Data</a> &gt;)</td></tr>
<tr class="memdesc:ab4fa618ff3ea408e48bc2184a9d16935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method for constructing an <a class="el" href="structkamping_1_1internal_1_1AllocNewDataBufferBuilder.html">AllocNewDataBufferBuilder</a> for <a class="el" href="group__kamping__mpi__utility.html#gaf7e87045435196cd49a0c3adcdf7c307">alloc_new</a>. <br /></td></tr>
<tr class="separator:ab4fa618ff3ea408e48bc2184a9d16935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571f965918a98d7b83ecdecabab81594" id="r_a571f965918a98d7b83ecdecabab81594"><td class="memTemplParams" colspan="2"><a id="a571f965918a98d7b83ecdecabab81594" name="a571f965918a98d7b83ecdecabab81594"></a>
template&lt;<a class="el" href="group__kamping__utility.html#ga0c6ea899ba6946f984708bfc852d44f1">ParameterType</a> parameter_type, <a class="el" href="#aee72027c50fd5cbf052ff6946cf1bbf5">BufferModifiability</a> modifiability, <a class="el" href="#af5d60ae867a369e93abb01f4cafe9549">BufferType</a> buffer_type, <a class="el" href="group__kamping__mpi__utility.html#ga76ff5c12e22ce699d271eddc97bc50f7">BufferResizePolicy</a> buffer_resize_policy, <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">ValueType</a>  = default_value_type_tag, <a class="el" href="classkamping_1_1MPIAllocator.html">template</a>&lt; typename... &gt; <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> Container&gt; </td></tr>
<tr class="memitem:a571f965918a98d7b83ecdecabab81594"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_data_buffer_builder</b> (<a class="el" href="structkamping_1_1AllocNewUsingT.html">AllocNewUsingT</a>&lt; <a class="el" href="classkamping_1_1MPIAllocator.html">Container</a> &gt;)</td></tr>
<tr class="memdesc:a571f965918a98d7b83ecdecabab81594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method for constructing an <a class="el" href="structkamping_1_1internal_1_1AllocNewDataBufferBuilder.html">AllocNewDataBufferBuilder</a> for <a class="el" href="group__kamping__mpi__utility.html#gad844f328b457a676276a88418c98b8ac">alloc_new_using</a>. <br /></td></tr>
<tr class="separator:a571f965918a98d7b83ecdecabab81594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884ab60d4a451d5e0a44eceda7a24021" id="r_a884ab60d4a451d5e0a44eceda7a24021"><td class="memTemplParams" colspan="2"><a id="a884ab60d4a451d5e0a44eceda7a24021" name="a884ab60d4a451d5e0a44eceda7a24021"></a>
template&lt;<a class="el" href="group__kamping__utility.html#ga0c6ea899ba6946f984708bfc852d44f1">ParameterType</a> parameter_type, <a class="el" href="#aee72027c50fd5cbf052ff6946cf1bbf5">BufferModifiability</a> modifiability, <a class="el" href="#af5d60ae867a369e93abb01f4cafe9549">BufferType</a> buffer_type, <a class="el" href="group__kamping__mpi__utility.html#ga76ff5c12e22ce699d271eddc97bc50f7">BufferResizePolicy</a> buffer_resize_policy, <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">ValueType</a> &gt; </td></tr>
<tr class="memitem:a884ab60d4a451d5e0a44eceda7a24021"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_data_buffer_builder</b> (<a class="el" href="structkamping_1_1AllocContainerOfT.html">AllocContainerOfT</a>&lt; <a class="el" href="classkamping_1_1MPIAllocator.html">ValueType</a> &gt;)</td></tr>
<tr class="memdesc:a884ab60d4a451d5e0a44eceda7a24021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method for constructing an <a class="el" href="structkamping_1_1internal_1_1AllocNewDataBufferBuilder.html">AllocNewDataBufferBuilder</a> for <a class="el" href="group__kamping__mpi__utility.html#ga70881031449cce5df630e5ad77a3299d">alloc_container_of</a>. <br /></td></tr>
<tr class="separator:a884ab60d4a451d5e0a44eceda7a24021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eed47df14071d5d4bdc258cb036d447" id="r_a2eed47df14071d5d4bdc258cb036d447"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">ValueType</a> , <a class="el" href="group__kamping__utility.html#ga0c6ea899ba6946f984708bfc852d44f1">ParameterType</a> parameter_type, <a class="el" href="#af5d60ae867a369e93abb01f4cafe9549">BufferType</a> buffer_type&gt; </td></tr>
<tr class="memitem:a2eed47df14071d5d4bdc258cb036d447"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2eed47df14071d5d4bdc258cb036d447">make_empty_data_buffer_builder</a> ()</td></tr>
<tr class="memdesc:a2eed47df14071d5d4bdc258cb036d447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method for constructing an <a class="el" href="structkamping_1_1internal_1_1DataBufferBuilder.html" title="Parameter object representing a data buffer. This is an intermediate object which only holds the data...">DataBufferBuilder</a> for an <a class="el" href="classkamping_1_1internal_1_1EmptyDataBuffer.html">EmptyDataBuffer</a>.  <br /></td></tr>
<tr class="separator:a2eed47df14071d5d4bdc258cb036d447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd73a5fedfca5602f45a0c696b30044" id="r_afbd73a5fedfca5602f45a0c696b30044"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">StatusParam</a> &gt; </td></tr>
<tr class="memitem:afbd73a5fedfca5602f45a0c696b30044"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">static</a> <a class="el" href="classkamping_1_1MPIAllocator.html">MPI_Status</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afbd73a5fedfca5602f45a0c696b30044">status_param_to_native_ptr</a> (<a class="el" href="classkamping_1_1MPIAllocator.html">StatusParam</a> &amp;<a class="el" href="classkamping_1_1MPIAllocator.html">param</a>)</td></tr>
<tr class="memdesc:afbd73a5fedfca5602f45a0c696b30044"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a pointer to the <code>MPI_Status</code> encapsulated by the provided status parameter object.  <br /></td></tr>
<tr class="separator:afbd73a5fedfca5602f45a0c696b30044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21bfaf5c0eed09eb3529ea2c05806455" id="r_a21bfaf5c0eed09eb3529ea2c05806455"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">CallerProvidedOwningOutBuffers</a> &gt; </td></tr>
<tr class="memitem:a21bfaf5c0eed09eb3529ea2c05806455"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a21bfaf5c0eed09eb3529ea2c05806455">return_recv_or_send_recv_buffer_only</a> ()</td></tr>
<tr class="memdesc:a21bfaf5c0eed09eb3529ea2c05806455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether only the recv (send_recv) buffer or multiple different buffers will be returned.  <br /></td></tr>
<tr class="separator:a21bfaf5c0eed09eb3529ea2c05806455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba60758aade132dbc657ddf0bda0847f" id="r_aba60758aade132dbc657ddf0bda0847f"><td class="memTemplParams" colspan="2">template&lt;typename... Buffers&gt; </td></tr>
<tr class="memitem:aba60758aade132dbc657ddf0bda0847f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="group__kamping__utility.html#ga0c6ea899ba6946f984708bfc852d44f1">ParameterType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aba60758aade132dbc657ddf0bda0847f">determine_recv_buffer_type</a> ()</td></tr>
<tr class="memdesc:aba60758aade132dbc657ddf0bda0847f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a buffer with parameter type recv_buf or a buffer with type send_recv_buf is present and returns the found parameter type. Note that we require that either a recv_buf or a send_recv_buf is present.  <br /></td></tr>
<tr class="separator:aba60758aade132dbc657ddf0bda0847f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44243e36be64b625b69be8b54a770b7" id="r_ab44243e36be64b625b69be8b54a770b7"><td class="memTemplParams" colspan="2">template&lt;typename... Buffers&gt; </td></tr>
<tr class="memitem:ab44243e36be64b625b69be8b54a770b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab44243e36be64b625b69be8b54a770b7">has_recv_or_send_recv_buf</a> ()</td></tr>
<tr class="memdesc:ab44243e36be64b625b69be8b54a770b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns True iff only a recv or send_recv buffer is present. <a class="el" href="group__kamping__collectives.html#ga168ff5f943c9301ddd3ff25eecd934d3" title="Perform a non-blocking barrier synchronization on this communicator using MPI_Ibarrier....">Communicator::ibarrier()</a>).  <br /></td></tr>
<tr class="separator:ab44243e36be64b625b69be8b54a770b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59574bbe9cf780470b35312bd1196419" id="r_a59574bbe9cf780470b35312bd1196419"><td class="memTemplParams" colspan="2"><a id="a59574bbe9cf780470b35312bd1196419" name="a59574bbe9cf780470b35312bd1196419"></a>
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">CallerProvidedOwningOutBuffers</a> , typename... Buffers&gt; </td></tr>
<tr class="memitem:a59574bbe9cf780470b35312bd1196419"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>return_send_buf_out_only</b> ()</td></tr>
<tr class="memdesc:a59574bbe9cf780470b35312bd1196419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether only the send buffer should be returned. This may happen if ownership of the send buffer is transfered to the call. <br /></td></tr>
<tr class="separator:a59574bbe9cf780470b35312bd1196419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad256a920b44aef089a398b516864694" id="r_aad256a920b44aef089a398b516864694"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">CallerProvidedArgs</a> , typename... Buffers&gt; </td></tr>
<tr class="memitem:aad256a920b44aef089a398b516864694"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aad256a920b44aef089a398b516864694">make_mpi_result</a> (<a class="el" href="classkamping_1_1MPIAllocator.html">Buffers</a> &amp;&amp;... <a class="el" href="classkamping_1_1MPIAllocator.html">buffers</a>)</td></tr>
<tr class="memdesc:aad256a920b44aef089a398b516864694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct result object for a wrapped MPI call. Four different cases are handled: a) The recv_buffer owns its underlying data (i.e. the received data has to be returned via the result object):  <br /></td></tr>
<tr class="separator:aad256a920b44aef089a398b516864694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb350eb7ef13229f2015638a18909358" id="r_afb350eb7ef13229f2015638a18909358"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">CallerProvidedArgs</a> , typename... Buffers&gt; </td></tr>
<tr class="memitem:afb350eb7ef13229f2015638a18909358"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afb350eb7ef13229f2015638a18909358">make_mpi_result_from_tuple</a> (std::tuple&lt; Buffers... &gt; &amp;<a class="el" href="classkamping_1_1MPIAllocator.html">buffers</a>)</td></tr>
<tr class="memdesc:afb350eb7ef13229f2015638a18909358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function to enable the construction of an <a class="el" href="classkamping_1_1MPIResult.html" title="MPIResult contains the result of a MPI call wrapped by KaMPIng.">MPIResult</a> object also if the buffers are stored inside a std::tuple. See <a class="el" href="#aad256a920b44aef089a398b516864694">make_mpi_result()</a> for more details.  <br /></td></tr>
<tr class="separator:afb350eb7ef13229f2015638a18909358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657573d935caa5784354fbbf9ab31bba" id="r_a657573d935caa5784354fbbf9ab31bba"><td class="memTemplParams" colspan="2">template&lt;typename... Buffers&gt; </td></tr>
<tr class="memitem:a657573d935caa5784354fbbf9ab31bba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a657573d935caa5784354fbbf9ab31bba">move_buffer_to_heap</a> (<a class="el" href="classkamping_1_1MPIAllocator.html">Buffers</a> &amp;&amp;... <a class="el" href="classkamping_1_1MPIAllocator.html">buffers</a>)</td></tr>
<tr class="memdesc:a657573d935caa5784354fbbf9ab31bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves given buffers into a std::tuple wrapped with an std::unique_ptr on the heap.  <br /></td></tr>
<tr class="separator:a657573d935caa5784354fbbf9ab31bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd633f76ea690f08cfa93708bf1b834" id="r_afdd633f76ea690f08cfa93708bf1b834"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">CallerProvidedArgsInTuple</a> , <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">RequestDataBuffer</a> , typename... Buffers&gt; </td></tr>
<tr class="memitem:afdd633f76ea690f08cfa93708bf1b834"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afdd633f76ea690f08cfa93708bf1b834">make_nonblocking_result</a> (<a class="el" href="classkamping_1_1MPIAllocator.html">RequestDataBuffer</a> &amp;&amp;<a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1a10573b873d2fa5a365d558a45e328e47">request</a>, std::unique_ptr&lt; std::tuple&lt; Buffers... &gt; &gt; <a class="el" href="classkamping_1_1MPIAllocator.html">buffers_on_heap</a>)</td></tr>
<tr class="memdesc:afdd633f76ea690f08cfa93708bf1b834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for creating a <a class="el" href="classkamping_1_1NonBlockingResult.html">kamping::NonBlockingResult</a>.  <br /></td></tr>
<tr class="separator:afdd633f76ea690f08cfa93708bf1b834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08aad76a01da6cad143342ca2a9c3ef9" id="r_a08aad76a01da6cad143342ca2a9c3ef9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">RequestDataBuffer</a> &gt; </td></tr>
<tr class="memitem:a08aad76a01da6cad143342ca2a9c3ef9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a08aad76a01da6cad143342ca2a9c3ef9">make_nonblocking_result</a> (<a class="el" href="classkamping_1_1MPIAllocator.html">RequestDataBuffer</a> &amp;&amp;<a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1a10573b873d2fa5a365d558a45e328e47">request</a>)</td></tr>
<tr class="memdesc:a08aad76a01da6cad143342ca2a9c3ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for creating a <a class="el" href="classkamping_1_1NonBlockingResult.html">kamping::NonBlockingResult</a>.  <br /></td></tr>
<tr class="separator:a08aad76a01da6cad143342ca2a9c3ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3abaef1e66a3a015daea23113fc8e1" id="r_a7f3abaef1e66a3a015daea23113fc8e1"><td class="memTemplParams" colspan="2"><a id="a7f3abaef1e66a3a015daea23113fc8e1" name="a7f3abaef1e66a3a015daea23113fc8e1"></a>
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">bool</a> serialization_used, <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="#af5d60ae867a369e93abb01f4cafe9549">BufferType</a> &gt; </td></tr>
<tr class="memitem:a7f3abaef1e66a3a015daea23113fc8e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserialization_repack</b> (<a class="el" href="#af5d60ae867a369e93abb01f4cafe9549">BufferType</a> <a class="el" href="classkamping_1_1MPIAllocator.html">buffer</a>)</td></tr>
<tr class="memdesc:a7f3abaef1e66a3a015daea23113fc8e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>serialization_used</code> is true, this takes a received serialization buffer, deserializes the data and repacks it into a new buffer only containing the deserialized data If <code>serialization_used</code> is false, the input buffer is returned unchanged. <br /></td></tr>
<tr class="separator:a7f3abaef1e66a3a015daea23113fc8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd8a103352c42bccbc7337f41aaabf9" id="r_acfd8a103352c42bccbc7337f41aaabf9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> T &gt; </td></tr>
<tr class="memitem:acfd8a103352c42bccbc7337f41aaabf9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acfd8a103352c42bccbc7337f41aaabf9">to_address</a> (T *<a class="el" href="classkamping_1_1MPIAllocator.html">p</a>) <a class="el" href="classkamping_1_1MPIAllocator.html">noexcept</a></td></tr>
<tr class="memdesc:acfd8a103352c42bccbc7337f41aaabf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the address represented by <code>p</code>. Modelled after C++20's <code>std::to_address</code>. See <a href="https://en.cppreference.com/w/cpp/memory/to_address">https://en.cppreference.com/w/cpp/memory/to_address</a> for details.  <br /></td></tr>
<tr class="separator:acfd8a103352c42bccbc7337f41aaabf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ed9536289a4fd106294a5ed577f116" id="r_ac4ed9536289a4fd106294a5ed577f116"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ac4ed9536289a4fd106294a5ed577f116"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac4ed9536289a4fd106294a5ed577f116">to_address</a> (T <a class="el" href="classkamping_1_1MPIAllocator.html">const</a> &amp;<a class="el" href="classkamping_1_1MPIAllocator.html">p</a>) <a class="el" href="classkamping_1_1MPIAllocator.html">noexcept</a></td></tr>
<tr class="memdesc:ac4ed9536289a4fd106294a5ed577f116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the address represented by <code>p</code>. Modelled after C++20's <code>std::to_address</code>. See <a href="https://en.cppreference.com/w/cpp/memory/to_address">https://en.cppreference.com/w/cpp/memory/to_address</a> for details.  <br /></td></tr>
<tr class="separator:ac4ed9536289a4fd106294a5ed577f116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb0f91c37ada00bb98d6f43b84b78a9" id="r_a3eb0f91c37ada00bb98d6f43b84b78a9"><td class="memTemplParams" colspan="2"><a id="a3eb0f91c37ada00bb98d6f43b84b78a9" name="a3eb0f91c37ada00bb98d6f43b84b78a9"></a>
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">F</a> &gt; </td></tr>
<tr class="memitem:a3eb0f91c37ada00bb98d6f43b84b78a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_callable_wrapper</b> (<a class="el" href="classkamping_1_1MPIAllocator.html">F</a> f)</td></tr>
<tr class="memdesc:a3eb0f91c37ada00bb98d6f43b84b78a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factory function for <a class="el" href="structkamping_1_1internal_1_1CallableWrapper.html">CallableWrapper</a>. <br /></td></tr>
<tr class="separator:a3eb0f91c37ada00bb98d6f43b84b78a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a50786eb4b9cfc3ba06f35157692cc213" id="r_a50786eb4b9cfc3ba06f35157692cc213"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> , <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a>  = void&gt; </td></tr>
<tr class="memitem:a50786eb4b9cfc3ba06f35157692cc213"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">static</a> <a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a50786eb4b9cfc3ba06f35157692cc213">has_value_type_v</a> = <a class="el" href="classkamping_1_1MPIAllocator.html">false</a></td></tr>
<tr class="memdesc:a50786eb4b9cfc3ba06f35157692cc213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean value helping to decide if type has a <code>value_type</code> member type.  <br /></td></tr>
<tr class="separator:a50786eb4b9cfc3ba06f35157692cc213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee45d0b822477ad64b17642f14ace96" id="r_a2ee45d0b822477ad64b17642f14ace96"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> T , <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a>  = void&gt; </td></tr>
<tr class="memitem:a2ee45d0b822477ad64b17642f14ace96"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">static</a> <a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2ee45d0b822477ad64b17642f14ace96">is_vector_bool_v</a> = <a class="el" href="classkamping_1_1MPIAllocator.html">false</a></td></tr>
<tr class="memdesc:a2ee45d0b822477ad64b17642f14ace96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean value helping to check if a type is an instance of <code>std::vector&lt;bool&gt;</code>.  <br /></td></tr>
<tr class="separator:a2ee45d0b822477ad64b17642f14ace96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057f780861d09a369e4e44c6a34b979b" id="r_a057f780861d09a369e4e44c6a34b979b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a057f780861d09a369e4e44c6a34b979b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a057f780861d09a369e4e44c6a34b979b">has_data_member_v</a> = <a class="el" href="structkamping_1_1internal_1_1has__data__member.html">has_data_member</a>&lt;T&gt;<a class="el" href="#a38bae4f1962cbd673975e8b8a74c098aa2063c1608d6e0baf80249c42e2be5804">::value</a></td></tr>
<tr class="memdesc:a057f780861d09a369e4e44c6a34b979b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean value helping to decide if data type has <code></code>.data() method.  <br /></td></tr>
<tr class="separator:a057f780861d09a369e4e44c6a34b979b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45221f637b75d06edf3390f51f90abb" id="r_ac45221f637b75d06edf3390f51f90abb"><td class="memTemplParams" colspan="2"><a id="ac45221f637b75d06edf3390f51f90abb" name="ac45221f637b75d06edf3390f51f90abb"></a>
template&lt;<a class="el" href="#aba5c5be2886443fbe345bc5430581727">BufferOwnership</a> ownership&gt; </td></tr>
<tr class="memitem:ac45221f637b75d06edf3390f51f90abb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enable_copy_construction_v</b> = (<a class="el" href="classkamping_1_1MPIAllocator.html">ownership</a> == BufferOwnership::referencing)</td></tr>
<tr class="memdesc:ac45221f637b75d06edf3390f51f90abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether copy construction is allowed for the given ownership. <br /></td></tr>
<tr class="separator:ac45221f637b75d06edf3390f51f90abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebc151ceb59db5b5d123e6cf02d69d0" id="r_a0ebc151ceb59db5b5d123e6cf02d69d0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">MemberType</a> &gt; </td></tr>
<tr class="memitem:a0ebc151ceb59db5b5d123e6cf02d69d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="group__kamping__mpi__utility.html#ga76ff5c12e22ce699d271eddc97bc50f7">BufferResizePolicy</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0ebc151ceb59db5b5d123e6cf02d69d0">maximum_viable_resize_policy</a></td></tr>
<tr class="memdesc:a0ebc151ceb59db5b5d123e6cf02d69d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">for a given  <br /></td></tr>
<tr class="separator:a0ebc151ceb59db5b5d123e6cf02d69d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11f96d35b1b145fb73b6296dcdf9c32" id="r_ab11f96d35b1b145fb73b6296dcdf9c32"><td class="memTemplParams" colspan="2"><a id="ab11f96d35b1b145fb73b6296dcdf9c32" name="ab11f96d35b1b145fb73b6296dcdf9c32"></a>
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ab11f96d35b1b145fb73b6296dcdf9c32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_empty_data_buffer_v</b> = <a class="el" href="classkamping_1_1MPIAllocator.html">false</a></td></tr>
<tr class="memdesc:ab11f96d35b1b145fb73b6296dcdf9c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to decide if a type is an instance of <code><a class="el" href="classkamping_1_1internal_1_1EmptyDataBuffer.html" title="Empty buffer that can be used as default argument for optional buffer parameters.">EmptyDataBuffer</a></code>. <br /></td></tr>
<tr class="separator:ab11f96d35b1b145fb73b6296dcdf9c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1a8bbf8d5e116a4641f8303a133e4f" id="r_a8c1a8bbf8d5e116a4641f8303a133e4f"><td class="memTemplParams" colspan="2"><a id="a8c1a8bbf8d5e116a4641f8303a133e4f" name="a8c1a8bbf8d5e116a4641f8303a133e4f"></a>
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> T , <a class="el" href="group__kamping__utility.html#ga0c6ea899ba6946f984708bfc852d44f1">ParameterType</a> type, <a class="el" href="#af5d60ae867a369e93abb01f4cafe9549">BufferType</a> buffer_type_param&gt; </td></tr>
<tr class="memitem:a8c1a8bbf8d5e116a4641f8303a133e4f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_empty_data_buffer_v&lt; EmptyDataBuffer&lt; T, type, buffer_type_param &gt; &gt;</b> = <a class="el" href="classkamping_1_1MPIAllocator.html">true</a></td></tr>
<tr class="memdesc:a8c1a8bbf8d5e116a4641f8303a133e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to decide if a type is an instance of <code><a class="el" href="classkamping_1_1internal_1_1EmptyDataBuffer.html" title="Empty buffer that can be used as default argument for optional buffer parameters.">EmptyDataBuffer</a></code>. <br /></td></tr>
<tr class="separator:a8c1a8bbf8d5e116a4641f8303a133e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028d94a09c9eaa700d9121525e38eb4b" id="r_a028d94a09c9eaa700d9121525e38eb4b"><td class="memItemLeft" align="right" valign="top"><a id="a028d94a09c9eaa700d9121525e38eb4b" name="a028d94a09c9eaa700d9121525e38eb4b"></a>
std::vector&lt; <a class="el" href="classkamping_1_1MPIAllocator.html">MPI_Datatype</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>registered_mpi_types</b></td></tr>
<tr class="memdesc:a028d94a09c9eaa700d9121525e38eb4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A global list of MPI data types registered to KaMPIng. <br /></td></tr>
<tr class="separator:a028d94a09c9eaa700d9121525e38eb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa13a9c31e6580708554a2a25567db6f" id="r_aaa13a9c31e6580708554a2a25567db6f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aaa13a9c31e6580708554a2a25567db6f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaa13a9c31e6580708554a2a25567db6f">tuple_size</a></td></tr>
<tr class="memdesc:aaa13a9c31e6580708554a2a25567db6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of elements in a tuple-like type. This works for <code>std::pair</code> and <code>std::tuple</code>. If KaMPIng's reflection support is enabled, this also works with types that are reflectable with <a href="https://github.com/boostorg/pfr">pfr</a>.  <br /></td></tr>
<tr class="separator:aaa13a9c31e6580708554a2a25567db6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9211561386dd18a38e40021409580ac8" id="r_a9211561386dd18a38e40021409580ac8"><td class="memTemplParams" colspan="2"><a id="a9211561386dd18a38e40021409580ac8" name="a9211561386dd18a38e40021409580ac8"></a>
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">Tuple</a> &gt; </td></tr>
<tr class="memitem:a9211561386dd18a38e40021409580ac8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">static</a> <a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>all_unique_v</b> = <a class="el" href="structkamping_1_1internal_1_1all__unique.html">all_unique</a>&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">Tuple</a>&gt;<a class="el" href="#a38bae4f1962cbd673975e8b8a74c098aa2063c1608d6e0baf80249c42e2be5804">::value</a></td></tr>
<tr class="memdesc:a9211561386dd18a38e40021409580ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>true</code> if and only if all types of the tuple are unique. <br /></td></tr>
<tr class="separator:a9211561386dd18a38e40021409580ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38696015377bbf1abf124c34b3eef293" id="r_a38696015377bbf1abf124c34b3eef293"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__kamping__utility.html#ga0c6ea899ba6946f984708bfc852d44f1">ParameterType</a> parameter_type, typename... Args&gt; </td></tr>
<tr class="memitem:a38696015377bbf1abf124c34b3eef293"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">static</a> <a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a38696015377bbf1abf124c34b3eef293">is_parameter_given_as_in_buffer</a></td></tr>
<tr class="memdesc:a38696015377bbf1abf124c34b3eef293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a data buffer with requested parameter type exists and it is an input parameter (i.e. its content does not have to be computed/deduced by KaMPIng).  <br /></td></tr>
<tr class="separator:a38696015377bbf1abf124c34b3eef293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae514065687a7c53cec3e14fb13e7957d" id="r_ae514065687a7c53cec3e14fb13e7957d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="#af5d60ae867a369e93abb01f4cafe9549">BufferType</a> &gt; </td></tr>
<tr class="memitem:ae514065687a7c53cec3e14fb13e7957d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">static</a> <a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae514065687a7c53cec3e14fb13e7957d">has_to_be_computed</a></td></tr>
<tr class="memdesc:ae514065687a7c53cec3e14fb13e7957d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the buffer has to be computed by kamping, i.e. if it is an output parameter or the buffer has been allocated by KaMPIng.  <br /></td></tr>
<tr class="separator:ae514065687a7c53cec3e14fb13e7957d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d03afea9aaea0164635f2d6d0dd81c" id="r_a62d03afea9aaea0164635f2d6d0dd81c"><td class="memTemplParams" colspan="2">template&lt;typename... BufferTypes&gt; </td></tr>
<tr class="memitem:a62d03afea9aaea0164635f2d6d0dd81c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">static</a> <a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a62d03afea9aaea0164635f2d6d0dd81c">all_have_to_be_computed</a> = (<a class="el" href="#ae514065687a7c53cec3e14fb13e7957d">has_to_be_computed</a>&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">BufferTypes</a>&gt; &amp;&amp; ...)</td></tr>
<tr class="memdesc:a62d03afea9aaea0164635f2d6d0dd81c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all buffers have to be computed by kamping, i.e., if all buffers are output parameters of the buffers have been allocated by kamping.  <br /></td></tr>
<tr class="separator:a62d03afea9aaea0164635f2d6d0dd81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004bdf42fe9235c4cff480e06d7857ba" id="r_a004bdf42fe9235c4cff480e06d7857ba"><td class="memTemplParams" colspan="2">template&lt;typename... BufferTypes&gt; </td></tr>
<tr class="memitem:a004bdf42fe9235c4cff480e06d7857ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">static</a> <a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a004bdf42fe9235c4cff480e06d7857ba">any_has_to_be_computed</a> = (<a class="el" href="#ae514065687a7c53cec3e14fb13e7957d">has_to_be_computed</a>&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">BufferTypes</a>&gt; || ...)</td></tr>
<tr class="memdesc:a004bdf42fe9235c4cff480e06d7857ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if any of the buffers have to be computed by kamping, i.e., if at least one buffer is an output parameter or has been allocated by kamping.  <br /></td></tr>
<tr class="separator:a004bdf42fe9235c4cff480e06d7857ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3e0d92881a71696b7d00e705d535db" id="r_a1c3e0d92881a71696b7d00e705d535db"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> DataBufferType &gt; </td></tr>
<tr class="memitem:a1c3e0d92881a71696b7d00e705d535db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">static</a> <a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1c3e0d92881a71696b7d00e705d535db">buffer_uses_serialization</a></td></tr>
<tr class="memdesc:a1c3e0d92881a71696b7d00e705d535db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>DataBufferType</code> is a serialization buffer.  <br /></td></tr>
<tr class="separator:a1c3e0d92881a71696b7d00e705d535db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ee7b1c6bb46950bc195a7ee1ba5044b" id="r_ga0ee7b1c6bb46950bc195a7ee1ba5044b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">Arg</a> &gt; </td></tr>
<tr class="memitem:ga0ee7b1c6bb46950bc195a7ee1ba5044b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="group__kamping__utility.html#gaa90eef75e8fcc9e6bd7e2ab7a9b2d4e3">parameter_type_t</a>&lt; <a class="el" href="classkamping_1_1MPIAllocator.html">Arg</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__kamping__utility.html#ga0ee7b1c6bb46950bc195a7ee1ba5044b">parameter_type_v</a> = <a class="el" href="structkamping_1_1internal_1_1ParameterTypeUnwrapping.html">ParameterTypeUnwrapping</a>&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">Arg</a>&gt;<a class="el" href="#a38bae4f1962cbd673975e8b8a74c098aa2063c1608d6e0baf80249c42e2be5804">::value</a></td></tr>
<tr class="memdesc:ga0ee7b1c6bb46950bc195a7ee1ba5044b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait for the underlying value of the parameter type of.  <br /></td></tr>
<tr class="separator:ga0ee7b1c6bb46950bc195a7ee1ba5044b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9331d266530a941f5884b0926b4875" id="r_a5d9331d266530a941f5884b0926b4875"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a5d9331d266530a941f5884b0926b4875"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5d9331d266530a941f5884b0926b4875">has_extract_v</a> = <a class="el" href="classkamping_1_1MPIAllocator.html">has_member_extract_v</a>&lt;T&gt;</td></tr>
<tr class="memdesc:a5d9331d266530a941f5884b0926b4875"><td class="mdescLeft">&#160;</td><td class="mdescRight">has_extract_v is <code>true</code> iff type T has a member function <code>extract()</code>.  <br /></td></tr>
<tr class="separator:a5d9331d266530a941f5884b0926b4875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03058951f31ece097f30c8cade4c0a20" id="r_a03058951f31ece097f30c8cade4c0a20"><td class="memTemplParams" colspan="2"><a id="a03058951f31ece097f30c8cade4c0a20" name="a03058951f31ece097f30c8cade4c0a20"></a>
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">Buffer</a> &gt; </td></tr>
<tr class="memitem:a03058951f31ece097f30c8cade4c0a20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_extractable</b> = Buffer::is_owning&amp;&amp; Buffer::is_out_buffer</td></tr>
<tr class="memdesc:a03058951f31ece097f30c8cade4c0a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for implementing the extract_* functions in <a class="el" href="classkamping_1_1MPIResult.html">MPIResult</a>. Is <code>true</code> if the passed buffer type owns its underlying storage and is an output buffer. <br /></td></tr>
<tr class="separator:a03058951f31ece097f30c8cade4c0a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84207557ad8ce39c4bfa004c74383ead" id="r_a84207557ad8ce39c4bfa004c74383ead"><td class="memTemplParams" colspan="2"><a id="a84207557ad8ce39c4bfa004c74383ead" name="a84207557ad8ce39c4bfa004c74383ead"></a>
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> , <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a>  = void&gt; </td></tr>
<tr class="memitem:a84207557ad8ce39c4bfa004c74383ead"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_data_buffer_type_member</b> = <a class="el" href="classkamping_1_1MPIAllocator.html">false</a></td></tr>
<tr class="memdesc:a84207557ad8ce39c4bfa004c74383ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to check if a type <code>T</code> has a member type <code>T::DataBufferType</code>. <br /></td></tr>
<tr class="separator:a84207557ad8ce39c4bfa004c74383ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ba7025b9882f0aac6ed54245babec6" id="r_a46ba7025b9882f0aac6ed54245babec6"><td class="memTemplParams" colspan="2"><a id="a46ba7025b9882f0aac6ed54245babec6" name="a46ba7025b9882f0aac6ed54245babec6"></a>
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> &gt; </td></tr>
<tr class="memitem:a46ba7025b9882f0aac6ed54245babec6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_serialization_buffer_v_impl</b> = <a class="el" href="classkamping_1_1MPIAllocator.html">false</a></td></tr>
<tr class="memdesc:a46ba7025b9882f0aac6ed54245babec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to check if a type is a serialization buffer. <br /></td></tr>
<tr class="separator:a46ba7025b9882f0aac6ed54245babec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217e1d25d04b1b98a88676503e6b6b43" id="r_a217e1d25d04b1b98a88676503e6b6b43"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a217e1d25d04b1b98a88676503e6b6b43"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a217e1d25d04b1b98a88676503e6b6b43">is_serialization_buffer_v</a></td></tr>
<tr class="memdesc:a217e1d25d04b1b98a88676503e6b6b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to check if a type is a serialization buffer.  <br /></td></tr>
<tr class="separator:a217e1d25d04b1b98a88676503e6b6b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Internal namespace marking the code that is not user-facing. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ae6b63ae79ebe32ba219cd0a5538f978a" name="ae6b63ae79ebe32ba219cd0a5538f978a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b63ae79ebe32ba219cd0a5538f978a">&#9670;&#160;</a></span>parameter_types_to_ignore_for_result_object</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">using</a> <a class="el" href="#ae6b63ae79ebe32ba219cd0a5538f978a">kamping::internal::parameter_types_to_ignore_for_result_object</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> type_list&lt;</div>
<div class="line">    ParameterTypeEntry&lt;ParameterType::op&gt;,</div>
<div class="line">    ParameterTypeEntry&lt;ParameterType::source&gt;,</div>
<div class="line">    ParameterTypeEntry&lt;ParameterType::destination&gt;,</div>
<div class="line">    ParameterTypeEntry&lt;ParameterType::statuses&gt;,</div>
<div class="line">    ParameterTypeEntry&lt;ParameterType::request&gt;,</div>
<div class="line">    ParameterTypeEntry&lt;ParameterType::root&gt;,</div>
<div class="line">    ParameterTypeEntry&lt;ParameterType::tag&gt;,</div>
<div class="line">    ParameterTypeEntry&lt;ParameterType::send_tag&gt;,</div>
<div class="line">    ParameterTypeEntry&lt;ParameterType::recv_tag&gt;,</div>
<div class="line">    ParameterTypeEntry&lt;ParameterType::send_mode&gt;,</div>
<div class="line">    ParameterTypeEntry&lt;ParameterType::values_on_rank_0&gt;&gt;</div>
</div><!-- fragment -->
<p>List of parameter type (entries) which should not be included in the result object. </p>

</div>
</div>
<a id="ac9c1b1558240ce44f906eb80e6bbfbbc" name="ac9c1b1558240ce44f906eb80e6bbfbbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c1b1558240ce44f906eb80e6bbfbbc">&#9670;&#160;</a></span>send_mode_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">using</a> <a class="el" href="#ac9c1b1558240ce44f906eb80e6bbfbbc">kamping::internal::send_mode_list</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    type_list&lt;standard_mode_t, buffered_mode_t, synchronous_mode_t, ready_mode_t&gt;</div>
</div><!-- fragment -->
<p>list of all available send modes </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a38bae4f1962cbd673975e8b8a74c098a" name="a38bae4f1962cbd673975e8b8a74c098a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38bae4f1962cbd673975e8b8a74c098a">&#9670;&#160;</a></span>RankType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">enum</a> <a class="el" href="classkamping_1_1MPIAllocator.html">class</a> <a class="el" href="#a38bae4f1962cbd673975e8b8a74c098a">kamping::internal::RankType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicator if a rank parameter holds and actual value or <code>MPI_ANY_SOURCE</code> or <code>MPI_PROC_NULL</code>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a38bae4f1962cbd673975e8b8a74c098aa2063c1608d6e0baf80249c42e2be5804" name="a38bae4f1962cbd673975e8b8a74c098aa2063c1608d6e0baf80249c42e2be5804"></a>value&#160;</td><td class="fielddoc"><p>holds a value </p>
</td></tr>
<tr><td class="fieldname"><a id="a38bae4f1962cbd673975e8b8a74c098aa100b8cad7cf2a56f6df78f171f97a1ec" name="a38bae4f1962cbd673975e8b8a74c098aa100b8cad7cf2a56f6df78f171f97a1ec"></a>any&#160;</td><td class="fielddoc"><p>holds <code>MPI_ANY_SOURCE</code> </p>
</td></tr>
<tr><td class="fieldname"><a id="a38bae4f1962cbd673975e8b8a74c098aa37a6259cc0c1dae299a7866489dff0bd" name="a38bae4f1962cbd673975e8b8a74c098aa37a6259cc0c1dae299a7866489dff0bd"></a>null&#160;</td><td class="fielddoc"><p>holds <code>MPI_PROC_NULL</code> </p>
</td></tr>
</table>

</div>
</div>
<a id="a287496ae13baab7eb561edb4c4948a43" name="a287496ae13baab7eb561edb4c4948a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287496ae13baab7eb561edb4c4948a43">&#9670;&#160;</a></span>TagType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">enum</a> <a class="el" href="classkamping_1_1MPIAllocator.html">class</a> <a class="el" href="#a287496ae13baab7eb561edb4c4948a43">kamping::internal::TagType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Possible types of tag. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a287496ae13baab7eb561edb4c4948a43a2063c1608d6e0baf80249c42e2be5804" name="a287496ae13baab7eb561edb4c4948a43a2063c1608d6e0baf80249c42e2be5804"></a>value&#160;</td><td class="fielddoc"><p>holds an actual value </p>
</td></tr>
<tr><td class="fieldname"><a id="a287496ae13baab7eb561edb4c4948a43a100b8cad7cf2a56f6df78f171f97a1ec" name="a287496ae13baab7eb561edb4c4948a43a100b8cad7cf2a56f6df78f171f97a1ec"></a>any&#160;</td><td class="fielddoc"><p>special value MPI_ANY_TAG} </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a397c69ed1325d75a0f0af9b174e39a1b" name="a397c69ed1325d75a0f0af9b174e39a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397c69ed1325d75a0f0af9b174e39a1b">&#9670;&#160;</a></span>are_neighborhoods_weighted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">NeighborhoodRange</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a> kamping::internal::are_neighborhoods_weighted </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether a given range of neighbors is weighted or not at compile time, i.e., whether the neighborhood only consists of ranks or of (rank, weight) pairs. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NeighborhoodRange</td><td>Range type to be checked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54f1f757f74353f0f5d88262990f0dca" name="a54f1f757f74353f0f5d88262990f0dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f1f757f74353f0f5d88262990f0dca">&#9670;&#160;</a></span>compute_required_recv_buf_size_in_vectorized_communication()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">RecvCounts</a> , <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">RecvDispls</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">size_t</a> kamping::internal::compute_required_recv_buf_size_in_vectorized_communication </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkamping_1_1MPIAllocator.html">RecvCounts</a> <a class="el" href="classkamping_1_1MPIAllocator.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>recv_counts</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkamping_1_1MPIAllocator.html">RecvDispls</a> <a class="el" href="classkamping_1_1MPIAllocator.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>recv_displs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkamping_1_1MPIAllocator.html">size_t</a></td>          <td class="paramname"><span class="paramname"><em>comm_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the required size of the recv buffer in vectorized communication (i.e. <code>MPI</code> operation that take a receive displacements). If recv displs are provided by the user the required size is the sum of the last entries of the recv_counts and the recv_displs buffers. Otherwise we have to compute the elementwise maximum of both buffers to obtain a minimum required recv buf size. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RecvCounts</td><td>Type of the recv counts buffer. </td></tr>
    <tr><td class="paramname">RecvDispls</td><td>Type of the recv displs buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recv_counts</td><td>Recv counts buffer. </td></tr>
    <tr><td class="paramname">recv_displs</td><td>Recv displs buffer. </td></tr>
    <tr><td class="paramname">comm_size</td><td>Size of the communicator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Required size of the recv buffer. </dd></dl>

</div>
</div>
<a id="afef350125bc9972442350922cdcd6c8c" name="afef350125bc9972442350922cdcd6c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef350125bc9972442350922cdcd6c8c">&#9670;&#160;</a></span>construct_buffer_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">ParameterTypeTuple</a> , typename... Buffers&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a> kamping::internal::construct_buffer_tuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkamping_1_1MPIAllocator.html">Buffers</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct tuple containing all buffers specified in. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ParamterTypeTuple.</td><td></td></tr>
    <tr><td class="paramname">ParameterTypeTuple</td><td>Tuple containing ParameterTypeEntries specifing the entries to be retrieved from the BufferTuple buffers. </td></tr>
    <tr><td class="paramname">Buffers</td><td>Types of the data buffers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>Data buffers out of which the ones with parameter types contained in ParameterTypeTuple are retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple containing all requested data buffers. </dd></dl>

</div>
</div>
<a id="a68357b6c4d61a873b4446165f3d6265c" name="a68357b6c4d61a873b4446165f3d6265c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68357b6c4d61a873b4446165f3d6265c">&#9670;&#160;</a></span>construct_buffer_tuple_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">ParameterTypeTuple</a> , typename... Buffers, std::size_t... i&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a> kamping::internal::construct_buffer_tuple_impl </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Buffers... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; i... &gt;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct tuple containing all buffers specified in. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ParamterTypeTuple.</td><td></td></tr>
    <tr><td class="paramname">ParameterTypeTuple</td><td>Tuple containing ParameterTypeEntries specifing the entries to be retrieved from the BufferTuple buffers. </td></tr>
    <tr><td class="paramname">Buffers</td><td>Types of the data buffers. </td></tr>
    <tr><td class="paramname">i</td><td>Integer sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>Data buffers out of which the ones with parameter types contained in ParameterTypeTuple are retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple containing all requested data buffers. </dd></dl>

</div>
</div>
<a id="ab57801ac8835484dab49470ef4a3440b" name="ab57801ac8835484dab49470ef4a3440b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab57801ac8835484dab49470ef4a3440b">&#9670;&#160;</a></span>determine_mpi_datatypes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">send_value_type</a> , <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">recv_value_type</a> , <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1a059c4e80690035e5a83497e4543c8523">recv_buf</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">auto</a> kamping::internal::determine_mpi_datatypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkamping_1_1MPIAllocator.html">Args</a> &amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deduce the MPI_Datatype to use on the send and recv side. If <a class="el" href="group__kamping__named__parameters.html#gab9a147682a19a084e087063a8080eca0">kamping::send_type()</a> is given, the <code>MPI_Datatype</code> wrapped inside will be used as send_type. Otherwise, the <code>MPI_datatype</code> is derived automatically based on send_buf's underlying <code>value_type</code>. </p>
<p>If <a class="el" href="group__kamping__named__parameters.html#gab151f99be902ed709832ae6e8be19d87">kamping::recv_type()</a> is given, the <code>MPI_Datatype</code> wrapped inside will be used as recv_type. Otherwise, the <code>MPI_datatype</code> is derived automatically based on recv_buf's underlying <code>value_type</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">send_value_type</td><td>Value type of the send buffer. </td></tr>
    <tr><td class="paramname">recv_value_type</td><td>Value type of the recv buffer. </td></tr>
    <tr><td class="paramname">recv_buf</td><td>Type of the recv buffer. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of all arguments passed to the wrapped MPI call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>All arguments passed to a wrapped MPI call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a tuple containing the <code>MPI</code> send_type wrapped in a <a class="el" href="classkamping_1_1internal_1_1DataBuffer.html" title="Data buffer used for named parameters.">DataBuffer</a>, the <code>MPI</code> recv_type wrapped in a <a class="el" href="classkamping_1_1internal_1_1DataBuffer.html" title="Data buffer used for named parameters.">DataBuffer</a>. </dd></dl>

</div>
</div>
<a id="a9d5785792eadf68f880a126ca6506a94" name="a9d5785792eadf68f880a126ca6506a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5785792eadf68f880a126ca6506a94">&#9670;&#160;</a></span>determine_mpi_recv_datatype()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">recv_value_type</a> , <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1a059c4e80690035e5a83497e4543c8523">recv_buf</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">auto</a> kamping::internal::determine_mpi_recv_datatype </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkamping_1_1MPIAllocator.html">Args</a> &amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="classkamping_1_1MPIAllocator.html">decltype</a>(<a class="el" href="group__kamping__utility.html#ga509c4c4989fa3924469e713dddb66c02">internal::select_parameter_type_or_default</a>&lt;
                    <a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1a3dd80893478c5fbd9e1507bca9358131">internal::ParameterType::recv_type</a>,
                    <a class="el" href="classkamping_1_1MPIAllocator.html">decltype</a>(<a class="el" href="group__kamping__named__parameters.html#ga5bb423bbc6d83e274aec7622104db943">kamping::recv_type_out</a>())&gt;(std::make_tuple(), args...)
                    .construct_buffer_or_rebind()) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deduce the MPI_Datatype to use as recv_type in a p2p recv operation.If <a class="el" href="group__kamping__named__parameters.html#gab151f99be902ed709832ae6e8be19d87">kamping::recv_type()</a> is given, the <code>MPI_Datatype</code> wrapped inside will be used as recv_type. Otherwise, the <code>MPI_datatype</code> is derived automatically based on recv_buf's underlying <code>value_type</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">recv_value_type</td><td>Value type of the recv buffer. </td></tr>
    <tr><td class="paramname">recv_buf</td><td>Type of the recv buffer. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of all arguments passed to the wrapped MPI call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>All arguments passed to a wrapped MPI call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the <code>MPI</code> recv_type wrapped in a <a class="el" href="classkamping_1_1internal_1_1DataBuffer.html" title="Data buffer used for named parameters.">DataBuffer</a>. This is either an lvalue reference to the recv_type <a class="el" href="classkamping_1_1internal_1_1DataBuffer.html" title="Data buffer used for named parameters.">DataBuffer</a> if the recv_type is provided by the user or a newly created recv_type <a class="el" href="classkamping_1_1internal_1_1DataBuffer.html" title="Data buffer used for named parameters.">DataBuffer</a> otherwise. </dd></dl>

</div>
</div>
<a id="aafabb03b2238196c2e5eeefad079440e" name="aafabb03b2238196c2e5eeefad079440e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafabb03b2238196c2e5eeefad079440e">&#9670;&#160;</a></span>determine_mpi_send_datatype()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">send_value_type</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">auto</a> kamping::internal::determine_mpi_send_datatype </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkamping_1_1MPIAllocator.html">Args</a> &amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="classkamping_1_1MPIAllocator.html">decltype</a>(<a class="el" href="group__kamping__utility.html#ga509c4c4989fa3924469e713dddb66c02">internal::select_parameter_type_or_default</a>&lt;
                    <a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1ab55f796cd7c01da784e597481890e01b">internal::ParameterType::send_type</a>,
                    <a class="el" href="classkamping_1_1MPIAllocator.html">decltype</a>(<a class="el" href="group__kamping__named__parameters.html#ga4f730152723b846b178035dd0ddfbc39">kamping::send_type_out</a>())&gt;(std::make_tuple(), args...)
                    .construct_buffer_or_rebind()) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deduce the MPI_Datatype to use as send_type in a p2p send operation.If <a class="el" href="group__kamping__named__parameters.html#gab9a147682a19a084e087063a8080eca0">kamping::send_type()</a> is given, the <code>MPI_Datatype</code> wrapped inside will be used as send_type. Otherwise, the <code>MPI_datatype</code> is derived automatically based on send_buf's underlying <code>value_type</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">send_value_type</td><td>Value type of the send buffer. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of all arguments passed to the wrapped MPI call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>All arguments passed to a wrapped MPI call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the <code>MPI</code> send_type wrapped in a <a class="el" href="classkamping_1_1internal_1_1DataBuffer.html" title="Data buffer used for named parameters.">DataBuffer</a>. This is either an lvalue reference to the send_type <a class="el" href="classkamping_1_1internal_1_1DataBuffer.html" title="Data buffer used for named parameters.">DataBuffer</a> if the send_type is provided by the user or a newly created send_type <a class="el" href="classkamping_1_1internal_1_1DataBuffer.html" title="Data buffer used for named parameters.">DataBuffer</a> otherwise. </dd></dl>

</div>
</div>
<a id="a1ddd5be97dce9b064c940f88ba734c98" name="a1ddd5be97dce9b064c940f88ba734c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ddd5be97dce9b064c940f88ba734c98">&#9670;&#160;</a></span>determine_mpi_send_recv_datatype()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">send_or_send_recv_value_type</a> , <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">recv_or_send_recv_buf</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">auto</a> kamping::internal::determine_mpi_send_recv_datatype </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkamping_1_1MPIAllocator.html">Args</a> &amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="classkamping_1_1MPIAllocator.html">decltype</a>(<a class="el" href="group__kamping__utility.html#ga509c4c4989fa3924469e713dddb66c02">internal::select_parameter_type_or_default</a>&lt;
                    <a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1a831e0f5546c437f7922dcd2f58b75b12">internal::ParameterType::send_recv_type</a>,
                    <a class="el" href="classkamping_1_1MPIAllocator.html">decltype</a>(<a class="el" href="group__kamping__named__parameters.html#ga4c7c40e498c68c12a46646e19865c853">kamping::send_recv_type_out</a>())&gt;(std::make_tuple(), args...)
                    .construct_buffer_or_rebind()) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deduce the MPI_Datatype to use as send_recv_type in a collective operation which accepts only one parameter of MPI_Datatype instead of (possibly) distinct send and recv types. If <a class="el" href="group__kamping__named__parameters.html#ga76c1572157e7012980fefec17534c085">kamping::send_recv_type()</a> is given, the <code>MPI_Datatype</code> wrapped inside will be used as send_recv_type. Otherwise, the <code>MPI_datatype</code> is derived automatically based on send_buf's underlying <code>value_type</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">send_or_send_recv_value_type</td><td>Value type of the send(_recv) buffer. </td></tr>
    <tr><td class="paramname">recv_buf</td><td>Value type of the send buffer. </td></tr>
    <tr><td class="paramname">recv_or_send_recv_buf</td><td>Type of the (send_)recv buffer. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of all arguments passed to the wrapped MPI call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>All arguments passed to a wrapped MPI call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the <code>MPI</code> send_type wrapped in a <a class="el" href="classkamping_1_1internal_1_1DataBuffer.html" title="Data buffer used for named parameters.">DataBuffer</a>. This is either an lvalue reference to the send_recv_type <a class="el" href="classkamping_1_1internal_1_1DataBuffer.html" title="Data buffer used for named parameters.">DataBuffer</a> if the send_recv_type is provided by the user or a newly created send_recv_type <a class="el" href="classkamping_1_1internal_1_1DataBuffer.html" title="Data buffer used for named parameters.">DataBuffer</a> otherwise. </dd></dl>

</div>
</div>
<a id="aba60758aade132dbc657ddf0bda0847f" name="aba60758aade132dbc657ddf0bda0847f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba60758aade132dbc657ddf0bda0847f">&#9670;&#160;</a></span>determine_recv_buffer_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Buffers&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="group__kamping__utility.html#ga0c6ea899ba6946f984708bfc852d44f1">ParameterType</a> kamping::internal::determine_recv_buffer_type </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether a buffer with parameter type recv_buf or a buffer with type send_recv_buf is present and returns the found parameter type. Note that we require that either a recv_buf or a send_recv_buf is present. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Buffers</td><td>All buffer types to be searched for type <code>recv_buf</code> or <code>send_recv_buf</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parameter type of the first buffer whose parameter type is recv_buf or send_recv_buf. </dd></dl>

</div>
</div>
<a id="a62afac32672786fd0541cca76e64c8bf" name="a62afac32672786fd0541cca76e64c8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62afac32672786fd0541cca76e64c8bf">&#9670;&#160;</a></span>for_each_field()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> T , <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">F</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">void</a> kamping::internal::for_each_field </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkamping_1_1MPIAllocator.html">F</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies functor <code>f</code> to each field of the tuple-like type <code>t</code>. This works for <code>std::pair</code> and <code>std::tuple</code>. If KaMPIng's reflection support is enabled, this also works with types that are reflectable with <a href="https://github.com/boostorg/pfr">pfr</a>. </p>
<p><code>f</code> should be a callable that takes a reference to the field and its index. </p>

</div>
</div>
<a id="a593049f3f20541d6fd688d79be48236d" name="a593049f3f20541d6fd688d79be48236d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593049f3f20541d6fd688d79be48236d">&#9670;&#160;</a></span>for_each_tuple_field() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> T , <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">F</a> , size_t... Is&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">void</a> kamping::internal::for_each_tuple_field </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkamping_1_1MPIAllocator.html">F</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; Is... &gt;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies functor <code>f</code> to each field of the tuple with an index in index sequence <code>Is</code>. </p>
<p><code>f</code> should be a callable that takes a reference to the field and its index. </p>

</div>
</div>
<a id="ae552657e8f8cd6538dffa3858a7934bb" name="ae552657e8f8cd6538dffa3858a7934bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae552657e8f8cd6538dffa3858a7934bb">&#9670;&#160;</a></span>for_each_tuple_field() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> T , <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">F</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">void</a> kamping::internal::for_each_tuple_field </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkamping_1_1MPIAllocator.html">F</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies functor <code>f</code> to each field of the tuple <code>t</code>. </p>
<p><code>f</code> should be a callable that takes a reference to the field and its index. </p>

</div>
</div>
<a id="ab44243e36be64b625b69be8b54a770b7" name="ab44243e36be64b625b69be8b54a770b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab44243e36be64b625b69be8b54a770b7">&#9670;&#160;</a></span>has_recv_or_send_recv_buf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Buffers&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a> kamping::internal::has_recv_or_send_recv_buf </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns True iff only a recv or send_recv buffer is present. <a class="el" href="group__kamping__collectives.html#ga168ff5f943c9301ddd3ff25eecd934d3" title="Perform a non-blocking barrier synchronization on this communicator using MPI_Ibarrier....">Communicator::ibarrier()</a>). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Buffers</td><td>All buffer types to be searched for type <code>status</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a024a8064235f280947475d671a9443" name="a3a024a8064235f280947475d671a9443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a024a8064235f280947475d671a9443">&#9670;&#160;</a></span>is_valid_rank_in_comm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">RankDataBufferClass</a> , <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">Comm</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a> kamping::internal::is_valid_rank_in_comm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkamping_1_1MPIAllocator.html">RankDataBufferClass</a> <a class="el" href="classkamping_1_1MPIAllocator.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rank_data_buffer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkamping_1_1MPIAllocator.html">Comm</a> <a class="el" href="classkamping_1_1MPIAllocator.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>comm</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkamping_1_1MPIAllocator.html">bool</a> <a class="el" href="classkamping_1_1MPIAllocator.html">const</a></td>          <td class="paramname"><span class="paramname"><em>allow_null</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classkamping_1_1MPIAllocator.html">false</a></span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkamping_1_1MPIAllocator.html">bool</a> <a class="el" href="classkamping_1_1MPIAllocator.html">const</a></td>          <td class="paramname"><span class="paramname"><em>allow_any</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classkamping_1_1MPIAllocator.html">false</a></span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether a <a class="el" href="classkamping_1_1internal_1_1RankDataBuffer.html" title="Encapsulates the rank of a PE. This is needed for p2p communication and rooted MPI collectives like M...">RankDataBuffer</a> contains a valid rank in the given communicator. </p>
<p>Can also be configured to accept <a class="el" href="#a38bae4f1962cbd673975e8b8a74c098aa37a6259cc0c1dae299a7866489dff0bd" title="holds MPI_PROC_NULL">RankType::null</a> or <a class="el" href="#a38bae4f1962cbd673975e8b8a74c098aa100b8cad7cf2a56f6df78f171f97a1ec" title="holds MPI_ANY_SOURCE">RankType::any</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rank_data_buffer</td><td>The <a class="el" href="classkamping_1_1internal_1_1RankDataBuffer.html" title="Encapsulates the rank of a PE. This is needed for p2p communication and rooted MPI collectives like M...">RankDataBuffer</a> encapsulating the rank to check. </td></tr>
    <tr><td class="paramname">comm</td><td>The <a class="el" href="classkamping_1_1Communicator.html" title="Wrapper for MPI communicator providing access to rank() and size() of the communicator....">Communicator</a> to check for validity in. </td></tr>
    <tr><td class="paramname">allow_null</td><td>Whether this function should return true for <a class="el" href="#a38bae4f1962cbd673975e8b8a74c098aa37a6259cc0c1dae299a7866489dff0bd" title="holds MPI_PROC_NULL">RankType::null</a>. </td></tr>
    <tr><td class="paramname">allow_any</td><td>Whether this function should return true for <a class="el" href="#a38bae4f1962cbd673975e8b8a74c098aa100b8cad7cf2a56f6df78f171f97a1ec" title="holds MPI_ANY_SOURCE">RankType::any</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RankDataBufferClass</td><td>The template instantiation of <a class="el" href="classkamping_1_1internal_1_1RankDataBuffer.html" title="Encapsulates the rank of a PE. This is needed for p2p communication and rooted MPI collectives like M...">RankDataBuffer</a>. </td></tr>
    <tr><td class="paramname">Comm</td><td>The template instantiation of <a class="el" href="classkamping_1_1Communicator.html" title="Wrapper for MPI communicator providing access to rank() and size() of the communicator....">Communicator</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a873a595ca729ddb13bbc9b66d1124373" name="a873a595ca729ddb13bbc9b66d1124373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873a595ca729ddb13bbc9b66d1124373">&#9670;&#160;</a></span>make_data_buffer() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">TParameterType</a> , <a class="el" href="classkamping_1_1MPIAllocator.html">TParameterType</a> parameter_type, <a class="el" href="#aee72027c50fd5cbf052ff6946cf1bbf5">BufferModifiability</a> modifiability, <a class="el" href="#af5d60ae867a369e93abb01f4cafe9549">BufferType</a> buffer_type, <a class="el" href="group__kamping__mpi__utility.html#ga76ff5c12e22ce699d271eddc97bc50f7">BufferResizePolicy</a> buffer_resize_policy, <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">ValueType</a>  = default_value_type_tag, <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">Data</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a> kamping::internal::make_data_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkamping_1_1AllocNewT.html">AllocNewT</a>&lt; <a class="el" href="classkamping_1_1MPIAllocator.html">Data</a> &gt;</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a library allocated <a class="el" href="classkamping_1_1internal_1_1DataBuffer.html" title="Data buffer used for named parameters.">DataBuffer</a> with the given container or single data type. </p>
<p>Creates a library allocated <a class="el" href="classkamping_1_1internal_1_1DataBuffer.html" title="Data buffer used for named parameters.">DataBuffer</a> with the given template parameters.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TParameterType</td><td>type of parameter type represented by this buffer. </td></tr>
    <tr><td class="paramname">parameter_type</td><td>parameter type represented by this buffer. </td></tr>
    <tr><td class="paramname">modifiability</td><td><code>modifiable</code> if a KaMPIng operation is allowed to modify the underlying container. <code>constant</code> otherwise. </td></tr>
    <tr><td class="paramname">buffer_type</td><td>Type of this buffer, i.e., in, out, or in_out. </td></tr>
    <tr><td class="paramname">buffer_resize_policy</td><td>Policy specifying whether (and if so, how) the underlying buffer shall be resized. </td></tr>
    <tr><td class="paramname">ValueType</td><td>Requested value type for the the data buffer. If not specified, it will be deduced from the underlying container and no checking is performed. </td></tr>
    <tr><td class="paramname">Data</td><td>Container or data type on which this buffer is based.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A library allocated <a class="el" href="classkamping_1_1internal_1_1DataBuffer.html" title="Data buffer used for named parameters.">DataBuffer</a> with the given template parameters. </dd></dl>

</div>
</div>
<a id="a19b28ebe97f38023ad60b0b8302fce56" name="a19b28ebe97f38023ad60b0b8302fce56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b28ebe97f38023ad60b0b8302fce56">&#9670;&#160;</a></span>make_data_buffer() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">TParameterType</a> , <a class="el" href="group__kamping__utility.html#ga0c6ea899ba6946f984708bfc852d44f1">ParameterType</a> parameter_type, <a class="el" href="#aee72027c50fd5cbf052ff6946cf1bbf5">BufferModifiability</a> modifiability, <a class="el" href="#af5d60ae867a369e93abb01f4cafe9549">BufferType</a> buffer_type, <a class="el" href="group__kamping__mpi__utility.html#ga76ff5c12e22ce699d271eddc97bc50f7">BufferResizePolicy</a> buffer_resize_policy, <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">ValueType</a>  = default_value_type_tag, <a class="el" href="classkamping_1_1MPIAllocator.html">template</a>&lt; typename... &gt; <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> Data&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a> kamping::internal::make_data_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkamping_1_1AllocNewUsingT.html">AllocNewUsingT</a>&lt; <a class="el" href="classkamping_1_1MPIAllocator.html">Data</a> &gt;</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a library allocated <a class="el" href="classkamping_1_1internal_1_1DataBuffer.html" title="Data buffer used for named parameters.">DataBuffer</a> by instantiating the given container template with the given value type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TParameterType</td><td>type of parameter type represented by this buffer. </td></tr>
    <tr><td class="paramname">parameter_type</td><td>parameter type represented by this buffer. </td></tr>
    <tr><td class="paramname">modifiability</td><td><code>modifiable</code> if a KaMPIng operation is allowed to modify the underlying container. <code>constant</code> otherwise. </td></tr>
    <tr><td class="paramname">buffer_type</td><td>Type of this buffer, i.e., in, out, or in_out. </td></tr>
    <tr><td class="paramname">buffer_resize_policy</td><td>Policy specifying whether (and if so, how) the underlying buffer shall be resized. </td></tr>
    <tr><td class="paramname">ValueType</td><td>The value type to initialize the <code>Data</code> template with. If not specified, this will fail. </td></tr>
    <tr><td class="paramname">Data</td><td>Container template this buffer is based on. The first template parameter is initialized with <code>ValueType</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A library allocated <a class="el" href="classkamping_1_1internal_1_1DataBuffer.html" title="Data buffer used for named parameters.">DataBuffer</a> with the given template parameters. </dd></dl>

</div>
</div>
<a id="af02cfe2c4e09251e5a488973dde68c13" name="af02cfe2c4e09251e5a488973dde68c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02cfe2c4e09251e5a488973dde68c13">&#9670;&#160;</a></span>make_data_buffer() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">TParameterType</a> , <a class="el" href="classkamping_1_1MPIAllocator.html">TParameterType</a> parameter_type, <a class="el" href="#aee72027c50fd5cbf052ff6946cf1bbf5">BufferModifiability</a> modifiability, <a class="el" href="#af5d60ae867a369e93abb01f4cafe9549">BufferType</a> buffer_type, <a class="el" href="group__kamping__mpi__utility.html#ga76ff5c12e22ce699d271eddc97bc50f7">BufferResizePolicy</a> buffer_resize_policy, <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">ValueType</a>  = default_value_type_tag, <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">Data</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a> kamping::internal::make_data_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkamping_1_1MPIAllocator.html">Data</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a user allocated <a class="el" href="classkamping_1_1internal_1_1DataBuffer.html" title="Data buffer used for named parameters.">DataBuffer</a> containing the supplied data (a container or a single element) </p>
<p>Creates a user allocated <a class="el" href="classkamping_1_1internal_1_1DataBuffer.html" title="Data buffer used for named parameters.">DataBuffer</a> with the given template parameters and ownership based on whether an rvalue or lvalue reference is passed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TParameterType</td><td>type of parameter type represented by this buffer. </td></tr>
    <tr><td class="paramname">parameter_type</td><td>parameter type represented by this buffer. </td></tr>
    <tr><td class="paramname">modifiability</td><td><code>modifiable</code> if a KaMPIng operation is allowed to modify the underlying container. <code>constant</code> otherwise. </td></tr>
    <tr><td class="paramname">buffer_type</td><td>Type of this buffer, i.e., in, out, or in_out. </td></tr>
    <tr><td class="paramname">Data</td><td>Container or data type on which this buffer is based. </td></tr>
    <tr><td class="paramname">buffer_resize_policy</td><td>Policy specifying whether (and if so, how) the underlying buffer shall be resized. </td></tr>
    <tr><td class="paramname">ValueType</td><td>Requested value type for the the data buffer. If not specified, it will be deduced from the underlying container and no checking is performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Universal reference to a container or single element holding the data for the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A user allocated <a class="el" href="classkamping_1_1internal_1_1DataBuffer.html" title="Data buffer used for named parameters.">DataBuffer</a> with the given template parameters and matching ownership. </dd></dl>

</div>
</div>
<a id="a7a4c25930d855a9e66c3b2ca061cbe2d" name="a7a4c25930d855a9e66c3b2ca061cbe2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a4c25930d855a9e66c3b2ca061cbe2d">&#9670;&#160;</a></span>make_data_buffer_builder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__kamping__utility.html#ga0c6ea899ba6946f984708bfc852d44f1">ParameterType</a> parameter_type, <a class="el" href="#aee72027c50fd5cbf052ff6946cf1bbf5">BufferModifiability</a> modifiability, <a class="el" href="#af5d60ae867a369e93abb01f4cafe9549">BufferType</a> buffer_type, <a class="el" href="group__kamping__mpi__utility.html#ga76ff5c12e22ce699d271eddc97bc50f7">BufferResizePolicy</a> buffer_resize_policy, <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">ValueType</a>  = default_value_type_tag, <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">Data</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a> kamping::internal::make_data_buffer_builder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkamping_1_1MPIAllocator.html">Data</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory method for constructing a <a class="el" href="structkamping_1_1internal_1_1DataBufferBuilder.html">DataBufferBuilder</a> from the given Container <code>Data</code>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structkamping_1_1internal_1_1DataBufferBuilder.html" title="Parameter object representing a data buffer. This is an intermediate object which only holds the data...">DataBufferBuilder</a> </dd></dl>

</div>
</div>
<a id="ad254b837335d9568056f1a9226ea7371" name="ad254b837335d9568056f1a9226ea7371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad254b837335d9568056f1a9226ea7371">&#9670;&#160;</a></span>make_data_buffer_builder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__kamping__utility.html#ga0c6ea899ba6946f984708bfc852d44f1">ParameterType</a> parameter_type, <a class="el" href="#aee72027c50fd5cbf052ff6946cf1bbf5">BufferModifiability</a> modifiability, <a class="el" href="#af5d60ae867a369e93abb01f4cafe9549">BufferType</a> buffer_type, <a class="el" href="group__kamping__mpi__utility.html#ga76ff5c12e22ce699d271eddc97bc50f7">BufferResizePolicy</a> buffer_resize_policy, <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">Data</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a> kamping::internal::make_data_buffer_builder </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classkamping_1_1MPIAllocator.html">Data</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory method for constructing a <a class="el" href="structkamping_1_1internal_1_1DataBufferBuilder.html">DataBufferBuilder</a> from an <code>std::initializer_list</code>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structkamping_1_1internal_1_1DataBufferBuilder.html" title="Parameter object representing a data buffer. This is an intermediate object which only holds the data...">DataBufferBuilder</a> </dd></dl>

</div>
</div>
<a id="a2eed47df14071d5d4bdc258cb036d447" name="a2eed47df14071d5d4bdc258cb036d447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eed47df14071d5d4bdc258cb036d447">&#9670;&#160;</a></span>make_empty_data_buffer_builder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">ValueType</a> , <a class="el" href="group__kamping__utility.html#ga0c6ea899ba6946f984708bfc852d44f1">ParameterType</a> parameter_type, <a class="el" href="#af5d60ae867a369e93abb01f4cafe9549">BufferType</a> buffer_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a> kamping::internal::make_empty_data_buffer_builder </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory method for constructing an <a class="el" href="structkamping_1_1internal_1_1DataBufferBuilder.html" title="Parameter object representing a data buffer. This is an intermediate object which only holds the data...">DataBufferBuilder</a> for an <a class="el" href="classkamping_1_1internal_1_1EmptyDataBuffer.html">EmptyDataBuffer</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structkamping_1_1internal_1_1DataBufferBuilder.html" title="Parameter object representing a data buffer. This is an intermediate object which only holds the data...">DataBufferBuilder</a> </dd></dl>

</div>
</div>
<a id="aad256a920b44aef089a398b516864694" name="aad256a920b44aef089a398b516864694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad256a920b44aef089a398b516864694">&#9670;&#160;</a></span>make_mpi_result()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">CallerProvidedArgs</a> , typename... Buffers&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a> kamping::internal::make_mpi_result </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkamping_1_1MPIAllocator.html">Buffers</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct result object for a wrapped MPI call. Four different cases are handled: a) The recv_buffer owns its underlying data (i.e. the received data has to be returned via the result object): </p>
<p>a.1) The recv_buffer is the only buffer to be returned, i.e. the only caller provided owning out buffer: In this case, the recv_buffers's underlying data is extracted and returned directly (by value).</p>
<p>a.2) There are multiple buffers to be returned and recv_buffer is explicitly provided by the caller: In this case a <a class="el" href="classkamping_1_1MPIResult.html">kamping::MPIResult</a> object is created, which stores the buffers to return (owning out buffers) in a std::tuple respecting the order in which these buffers where provided to the wrapped MPI call. This enables unpacking the object via structured binding.</p>
<p>a.3) There are more data buffers to be returned and recv_buffer is <em>not</em> explicitly provided by the caller: In this case a <a class="el" href="classkamping_1_1MPIResult.html">kamping::MPIResult</a> object is created, which stores the buffers to return. The recv_buffer is always the first entry in the result object followed by the other buffers respecting the order in which these buffers where provided to the wrapped MPI call.</p>
<p>b) There is no recv buffer (see <a class="el" href="group__kamping__p2p.html#ga4bb25d15e81a7149e2eda05eb44f6782">Communicator::probe()</a> for example) or the recv_buffer only references its underlying data (i.e. it is a non-owning out buffer): In this case recv_buffer is not part of the result object. The <a class="el" href="classkamping_1_1MPIResult.html">kamping::MPIResult</a> object stores the buffer to return (owning buffers for which a *_out() named parameter was passed to the wrapped MPI call) in a std::tuple respecting the order in which these buffers where provided to the wrapped MPI call.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CallerProvidedArgs</td><td>Types of arguments passed to the wrapped MPI call. </td></tr>
    <tr><td class="paramname">Buffers</td><td>Types of data buffers created/filled within the wrapped MPI call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>data buffers created/filled within the wrapped MPI call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result object as specified above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parameter_handling.html#md_docs_2parameter__handling">docs/parameter_handling.md</a> </dd></dl>

</div>
</div>
<a id="afb350eb7ef13229f2015638a18909358" name="afb350eb7ef13229f2015638a18909358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb350eb7ef13229f2015638a18909358">&#9670;&#160;</a></span>make_mpi_result_from_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">CallerProvidedArgs</a> , typename... Buffers&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a> kamping::internal::make_mpi_result_from_tuple </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Buffers... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper function to enable the construction of an <a class="el" href="classkamping_1_1MPIResult.html" title="MPIResult contains the result of a MPI call wrapped by KaMPIng.">MPIResult</a> object also if the buffers are stored inside a std::tuple. See <a class="el" href="#aad256a920b44aef089a398b516864694">make_mpi_result()</a> for more details. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CallerProvidedArgs</td><td>Types of arguments passed to the wrapped MPI call. </td></tr>
    <tr><td class="paramname">Buffers</td><td>Types of data buffers created/filled within the wrapped MPI call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>data buffers created/filled within the wrapped MPI call bundled within a std::tuple. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08aad76a01da6cad143342ca2a9c3ef9" name="a08aad76a01da6cad143342ca2a9c3ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08aad76a01da6cad143342ca2a9c3ef9">&#9670;&#160;</a></span>make_nonblocking_result() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">RequestDataBuffer</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a> kamping::internal::make_nonblocking_result </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkamping_1_1MPIAllocator.html">RequestDataBuffer</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>request</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory for creating a <a class="el" href="classkamping_1_1NonBlockingResult.html">kamping::NonBlockingResult</a>. </p>
<p>Makes an <a class="el" href="classkamping_1_1NonBlockingResult.html">kamping::NonBlockingResult</a> from all arguments passed and inserts <a class="el" href="structkamping_1_1internal_1_1ResultCategoryNotUsed.html" title="Use this type if one of the template parameters of MPIResult is not used for a specific wrapped MPI c...">internal::ResultCategoryNotUsed</a> when no fitting parameter type is passed as argument.</p>
<p>Note that an argument of with type <a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1a10573b873d2fa5a365d558a45e328e47">kamping::internal::ParameterType::request</a> is required.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RequestDataBuffer</td><td>Container encapsulating the underlying request. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td><a class="el" href="classkamping_1_1Request.html" title="Wrapper for MPI request handles (aka. MPI_Request).">Request</a> associated with the non-blocking <code>MPI</code> call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classkamping_1_1NonBlockingResult.html">kamping::NonBlockingResult</a> encapsulating all passed parameters. </dd></dl>

</div>
</div>
<a id="afdd633f76ea690f08cfa93708bf1b834" name="afdd633f76ea690f08cfa93708bf1b834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd633f76ea690f08cfa93708bf1b834">&#9670;&#160;</a></span>make_nonblocking_result() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">CallerProvidedArgsInTuple</a> , <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">RequestDataBuffer</a> , typename... Buffers&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a> kamping::internal::make_nonblocking_result </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkamping_1_1MPIAllocator.html">RequestDataBuffer</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>request</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; std::tuple&lt; Buffers... &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>buffers_on_heap</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory for creating a <a class="el" href="classkamping_1_1NonBlockingResult.html">kamping::NonBlockingResult</a>. </p>
<p>Makes an <a class="el" href="classkamping_1_1NonBlockingResult.html">kamping::NonBlockingResult</a> from all arguments passed and inserts <a class="el" href="structkamping_1_1internal_1_1ResultCategoryNotUsed.html" title="Use this type if one of the template parameters of MPIResult is not used for a specific wrapped MPI c...">internal::ResultCategoryNotUsed</a> when no fitting parameter type is passed as argument.</p>
<p>Note that an argument of with type <a class="el" href="group__kamping__utility.html#gga0c6ea899ba6946f984708bfc852d44f1a10573b873d2fa5a365d558a45e328e47">kamping::internal::ParameterType::request</a> is required.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CallerProvidedArgs</td><td>Types of arguments passed to the wrapped MPI call. </td></tr>
    <tr><td class="paramname">RequestDataBuffer</td><td>Container encapsulating the underlying request. </td></tr>
    <tr><td class="paramname">Buffers</td><td>Types of buffers associated with the underlying non-blocking MPI call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td><a class="el" href="classkamping_1_1Request.html" title="Wrapper for MPI request handles (aka. MPI_Request).">Request</a> associated with the non-blocking <code>MPI</code> call. </td></tr>
    <tr><td class="paramname">buffers_on_heap</td><td>Buffers associated with the non-blocking <code>MPI</code> call stored in a tuple on the heap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classkamping_1_1NonBlockingResult.html">kamping::NonBlockingResult</a> encapsulating all passed parameters. </dd></dl>

</div>
</div>
<a id="a657573d935caa5784354fbbf9ab31bba" name="a657573d935caa5784354fbbf9ab31bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657573d935caa5784354fbbf9ab31bba">&#9670;&#160;</a></span>move_buffer_to_heap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Buffers&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a> kamping::internal::move_buffer_to_heap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkamping_1_1MPIAllocator.html">Buffers</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves given buffers into a std::tuple wrapped with an std::unique_ptr on the heap. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Buffers...</td><td>Types of the buffers to be moved to the heap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>Buffers to be moved to the heap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr wrapping a std::tuple containing the passed buffers. </dd></dl>

</div>
</div>
<a id="ada625152fce9d38c862b1f44929cfa95" name="ada625152fce9d38c862b1f44929cfa95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada625152fce9d38c862b1f44929cfa95">&#9670;&#160;</a></span>retrieve_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__kamping__utility.html#ga0c6ea899ba6946f984708bfc852d44f1">internal::ParameterType</a> ptype, typename... Buffers&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a> &amp; kamping::internal::retrieve_buffer </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Buffers... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the buffer with requested ParameterType from the std::tuple containg all buffers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ptype</td><td>ParameterType of the buffer to retrieve. </td></tr>
    <tr><td class="paramname">Buffers</td><td>Types of the data buffers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>Data buffers out of which the one with requested parameter type is retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the buffer which the requested ParameterType. </dd></dl>

</div>
</div>
<a id="a21bfaf5c0eed09eb3529ea2c05806455" name="a21bfaf5c0eed09eb3529ea2c05806455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21bfaf5c0eed09eb3529ea2c05806455">&#9670;&#160;</a></span>return_recv_or_send_recv_buffer_only()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">CallerProvidedOwningOutBuffers</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a> kamping::internal::return_recv_or_send_recv_buffer_only </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether only the recv (send_recv) buffer or multiple different buffers will be returned. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CallerProvidedOwningOutBuffers</td><td>An std::tuple containing the types of the owning, out buffers explicitly requested by the caller of the wrapped MPI call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if the recv (send_recv) buffer is either not mentioned explicitly and no other (owning) out buffers are requested or the only explicitly requested owning out buffer is the recv_buf. <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a id="afbd73a5fedfca5602f45a0c696b30044" name="afbd73a5fedfca5602f45a0c696b30044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbd73a5fedfca5602f45a0c696b30044">&#9670;&#160;</a></span>status_param_to_native_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">StatusParam</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">static</a> <a class="el" href="classkamping_1_1MPIAllocator.html">MPI_Status</a> * kamping::internal::status_param_to_native_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkamping_1_1MPIAllocator.html">StatusParam</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>param</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a pointer to the <code>MPI_Status</code> encapsulated by the provided status parameter object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StatusParam</td><td>The type of the status parameter object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>The status parameter object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the encapsulated <code>MPI_Status</code> or <code>MPI_STATUS_IGNORE</code>. </dd></dl>

</div>
</div>
<a id="acfd8a103352c42bccbc7337f41aaabf9" name="acfd8a103352c42bccbc7337f41aaabf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfd8a103352c42bccbc7337f41aaabf9">&#9670;&#160;</a></span>to_address() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> T * kamping::internal::to_address </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the address represented by <code>p</code>. Modelled after C++20's <code>std::to_address</code>. See <a href="https://en.cppreference.com/w/cpp/memory/to_address">https://en.cppreference.com/w/cpp/memory/to_address</a> for details. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>a raw pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">the</td><td>underlying type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4ed9536289a4fd106294a5ed577f116" name="ac4ed9536289a4fd106294a5ed577f116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ed9536289a4fd106294a5ed577f116">&#9670;&#160;</a></span>to_address() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">auto</a> kamping::internal::to_address </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="classkamping_1_1MPIAllocator.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the address represented by <code>p</code>. Modelled after C++20's <code>std::to_address</code>. See <a href="https://en.cppreference.com/w/cpp/memory/to_address">https://en.cppreference.com/w/cpp/memory/to_address</a> for details. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>a smart pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">the</td><td>pointer type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace93d4e5a4b4c7c054604ccd31d42906" name="ace93d4e5a4b4c7c054604ccd31d42906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace93d4e5a4b4c7c054604ccd31d42906">&#9670;&#160;</a></span>with_operation_functor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">Functor</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">auto</a> kamping::internal::with_operation_functor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkamping_1_1MPIAllocator.html">MPI_Op</a></td>          <td class="paramname"><span class="paramname"><em>op</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkamping_1_1MPIAllocator.html">Functor</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function that maps an <code>MPI_Op</code> to the matching functor from <code><a class="el" href="namespacekamping_1_1ops.html" title="this namespace contains all builtin operations supported by MPI.">kamping::ops</a></code>. In case no function maps, the functor is called with <code>kamping::ops::null&lt;&gt;{}</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation. </td></tr>
    <tr><td class="paramname">func</td><td>The lambda to be called with the functor matching the <code>MPI_Op</code>, e.g. in the case of <code>MPI_SUM</code> we call <code>func</code>(<a class="el" href="namespacekamping_1_1ops.html#ab2c53a3bc88717a34748749b1ce43a89" title="builtin summation operation (aka MPI_SUM)">kamping::ops::plus&lt;&gt;</a>{}). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a62d03afea9aaea0164635f2d6d0dd81c" name="a62d03afea9aaea0164635f2d6d0dd81c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d03afea9aaea0164635f2d6d0dd81c">&#9670;&#160;</a></span>all_have_to_be_computed</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... BufferTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a> kamping::internal::all_have_to_be_computed = (<a class="el" href="#ae514065687a7c53cec3e14fb13e7957d">has_to_be_computed</a>&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">BufferTypes</a>&gt; &amp;&amp; ...)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if all buffers have to be computed by kamping, i.e., if all buffers are output parameters of the buffers have been allocated by kamping. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BufferTypes</td><td>Any number of buffers types to be checked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a004bdf42fe9235c4cff480e06d7857ba" name="a004bdf42fe9235c4cff480e06d7857ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a004bdf42fe9235c4cff480e06d7857ba">&#9670;&#160;</a></span>any_has_to_be_computed</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... BufferTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a> kamping::internal::any_has_to_be_computed = (<a class="el" href="#ae514065687a7c53cec3e14fb13e7957d">has_to_be_computed</a>&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">BufferTypes</a>&gt; || ...)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if any of the buffers have to be computed by kamping, i.e., if at least one buffer is an output parameter or has been allocated by kamping. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BufferTypes</td><td>Any number of buffers to be checked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c3e0d92881a71696b7d00e705d535db" name="a1c3e0d92881a71696b7d00e705d535db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c3e0d92881a71696b7d00e705d535db">&#9670;&#160;</a></span>buffer_uses_serialization</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> DataBufferType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a> kamping::internal::buffer_uses_serialization</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= internal::is_serialization_buffer_v&lt;</div>
<div class="line">    <span class="keyword">typename</span> std::remove_const_t&lt;std::remove_reference_t&lt;DataBufferType&gt;&gt;::MemberTypeWithConstAndRef&gt;</div>
</div><!-- fragment -->
<p>Checks if <code>DataBufferType</code> is a serialization buffer. </p>

</div>
</div>
<a id="a057f780861d09a369e4e44c6a34b979b" name="a057f780861d09a369e4e44c6a34b979b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a057f780861d09a369e4e44c6a34b979b">&#9670;&#160;</a></span>has_data_member_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a> kamping::internal::has_data_member_v = <a class="el" href="structkamping_1_1internal_1_1has__data__member.html">has_data_member</a>&lt;T&gt;<a class="el" href="#a38bae4f1962cbd673975e8b8a74c098aa2063c1608d6e0baf80249c42e2be5804">::value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Boolean value helping to decide if data type has <code></code>.data() method. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if class has <code></code>.data() method and <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a5d9331d266530a941f5884b0926b4875" name="a5d9331d266530a941f5884b0926b4875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d9331d266530a941f5884b0926b4875">&#9670;&#160;</a></span>has_extract_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a> kamping::internal::has_extract_v = <a class="el" href="classkamping_1_1MPIAllocator.html">has_member_extract_v</a>&lt;T&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>has_extract_v is <code>true</code> iff type T has a member function <code>extract()</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type which is tested for the existence of a member function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae514065687a7c53cec3e14fb13e7957d" name="ae514065687a7c53cec3e14fb13e7957d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae514065687a7c53cec3e14fb13e7957d">&#9670;&#160;</a></span>has_to_be_computed</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="#af5d60ae867a369e93abb01f4cafe9549">BufferType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a> kamping::internal::has_to_be_computed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    std::remove_reference_t&lt;BufferType&gt;::is_out_buffer || std::remove_reference_t&lt;BufferType&gt;::is_lib_allocated</div>
</div><!-- fragment -->
<p>Checks if the buffer has to be computed by kamping, i.e. if it is an output parameter or the buffer has been allocated by KaMPIng. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BufferType</td><td>The buffer type to be checked </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50786eb4b9cfc3ba06f35157692cc213" name="a50786eb4b9cfc3ba06f35157692cc213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50786eb4b9cfc3ba06f35157692cc213">&#9670;&#160;</a></span>has_value_type_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> , <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a>  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a> kamping::internal::has_value_type_v = <a class="el" href="classkamping_1_1MPIAllocator.html">false</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Boolean value helping to decide if type has a <code>value_type</code> member type. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if class has <code>value_type</code> method and <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a38696015377bbf1abf124c34b3eef293" name="a38696015377bbf1abf124c34b3eef293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38696015377bbf1abf124c34b3eef293">&#9670;&#160;</a></span>is_parameter_given_as_in_buffer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__kamping__utility.html#ga0c6ea899ba6946f984708bfc852d44f1">ParameterType</a> parameter_type, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a> kamping::internal::is_parameter_given_as_in_buffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= []() {</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> found_pos = find_pos&lt;std::integral_constant&lt;ParameterType, parameter_type&gt;, 0, Args...&gt;();</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (found_pos &gt;= <span class="keyword">sizeof</span>...(Args)) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keyword">using </span><a class="code hl_class" href="classkamping_1_1MPIAllocator.html">FoundType</a> = std::tuple_element_t&lt;<a class="code hl_class" href="classkamping_1_1MPIAllocator.html">found_pos</a>, std::tuple&lt;<a class="code hl_class" href="classkamping_1_1MPIAllocator.html">Args</a>...&gt;&gt;;</div>
<div class="line">        <span class="keywordflow">return</span> !FoundType::is_out_buffer;</div>
<div class="line">    }</div>
<div class="line">}()</div>
<div class="ttc" id="aclasskamping_1_1MPIAllocator_html"><div class="ttname"><a href="classkamping_1_1MPIAllocator.html">kamping::MPIAllocator</a></div><div class="ttdoc">STL-compatible allocator for requesting memory using the builtin MPI allocator.</div><div class="ttdef"><b>Definition</b> allocator.hpp:32</div></div>
</div><!-- fragment -->
<p>Checks if a data buffer with requested parameter type exists and it is an input parameter (i.e. its content does not have to be computed/deduced by KaMPIng). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">parameter_type</td><td>The parameter type for which a parameter should be found. </td></tr>
    <tr><td class="paramname">Args</td><td>All parameter types to be searched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff. <code>Args</code> contains a parameter of type <code>parameter_type</code> and this parameter is not an output buffer. </dd></dl>

</div>
</div>
<a id="a217e1d25d04b1b98a88676503e6b6b43" name="a217e1d25d04b1b98a88676503e6b6b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a217e1d25d04b1b98a88676503e6b6b43">&#9670;&#160;</a></span>is_serialization_buffer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a> kamping::internal::is_serialization_buffer_v</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    is_serialization_buffer_v_impl&lt;std::remove_const_t&lt;std::remove_reference_t&lt;T&gt;&gt;&gt;</div>
</div><!-- fragment -->
<p>Type trait to check if a type is a serialization buffer. </p>

</div>
</div>
<a id="a2ee45d0b822477ad64b17642f14ace96" name="a2ee45d0b822477ad64b17642f14ace96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee45d0b822477ad64b17642f14ace96">&#9670;&#160;</a></span>is_vector_bool_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> T , <a class="el" href="classkamping_1_1MPIAllocator.html">typename</a>  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">bool</a> kamping::internal::is_vector_bool_v = <a class="el" href="classkamping_1_1MPIAllocator.html">false</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Boolean value helping to check if a type is an instance of <code>std::vector&lt;bool&gt;</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>T</code> is an template instance of <code>std::vector&lt;bool&gt;</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a0ebc151ceb59db5b5d123e6cf02d69d0" name="a0ebc151ceb59db5b5d123e6cf02d69d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ebc151ceb59db5b5d123e6cf02d69d0">&#9670;&#160;</a></span>maximum_viable_resize_policy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> <a class="el" href="classkamping_1_1MPIAllocator.html">MemberType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="group__kamping__mpi__utility.html#ga76ff5c12e22ce699d271eddc97bc50f7">BufferResizePolicy</a> kamping::internal::maximum_viable_resize_policy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [] {</div>
<div class="line">    <span class="keyword">auto</span> is_single_element = !has_data_member_v&lt;MemberType&gt;;</div>
<div class="line">    <span class="keywordflow">if</span> (is_single_element || !has_member_resize_v&lt;MemberType, size_t&gt;) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_variable" href="group__kamping__mpi__utility.html#gae63787fc9f8fa60f80cb82e5fd1ae495">no_resize</a>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_variable" href="group__kamping__mpi__utility.html#ga3743eb9b8525a2e6407ec61383e0f8fa">resize_to_fit</a>;</div>
<div class="line">    }</div>
<div class="line">}()</div>
<div class="ttc" id="agroup__kamping__mpi__utility_html_ga3743eb9b8525a2e6407ec61383e0f8fa"><div class="ttname"><a href="group__kamping__mpi__utility.html#ga3743eb9b8525a2e6407ec61383e0f8fa">kamping::resize_to_fit</a></div><div class="ttdeci">constexpr BufferResizePolicy resize_to_fit</div><div class="ttdef"><b>Definition</b> data_buffer.hpp:306</div></div>
<div class="ttc" id="agroup__kamping__mpi__utility_html_gae63787fc9f8fa60f80cb82e5fd1ae495"><div class="ttname"><a href="group__kamping__mpi__utility.html#gae63787fc9f8fa60f80cb82e5fd1ae495">kamping::no_resize</a></div><div class="ttdeci">constexpr BufferResizePolicy no_resize</div><div class="ttdef"><b>Definition</b> data_buffer.hpp:300</div></div>
</div><!-- fragment -->
<p>for a given </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MemberType</td><td>of a data buffer, defines the most viable resize policy.</td></tr>
  </table>
  </dd>
</dl>
<p>For example, a single element buffer may not be resizable. </p>

</div>
</div>
<a id="aaa13a9c31e6580708554a2a25567db6f" name="aaa13a9c31e6580708554a2a25567db6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa13a9c31e6580708554a2a25567db6f">&#9670;&#160;</a></span>tuple_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classkamping_1_1MPIAllocator.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkamping_1_1MPIAllocator.html">constexpr</a> <a class="el" href="classkamping_1_1MPIAllocator.html">size_t</a> kamping::internal::tuple_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [] {</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (internal::is_std_pair&lt;T&gt;::value) {</div>
<div class="line">        <span class="keywordflow">return</span> 2;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (<a class="code hl_struct" href="structkamping_1_1internal_1_1is__std__tuple.html">internal::is_std_tuple&lt;T&gt;::value</a>) {</div>
<div class="line">        <span class="keywordflow">return</span> std::tuple_size_v&lt;T&gt;;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::is_arithmetic_v&lt;T&gt;) {</div>
<div class="line">            <span class="keywordflow">return</span> 1;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="keywordflow">return</span> std::tuple_size_v&lt;T&gt;;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line">}()</div>
<div class="ttc" id="astructkamping_1_1internal_1_1is__std__tuple_html"><div class="ttname"><a href="structkamping_1_1internal_1_1is__std__tuple.html">kamping::internal::is_std_tuple</a></div><div class="ttdoc">Helper to check if a type is a std::tuple.</div><div class="ttdef"><b>Definition</b> mpi_datatype.hpp:54</div></div>
</div><!-- fragment -->
<p>The number of elements in a tuple-like type. This works for <code>std::pair</code> and <code>std::tuple</code>. If KaMPIng's reflection support is enabled, this also works with types that are reflectable with <a href="https://github.com/boostorg/pfr">pfr</a>. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>kamping</b></li><li class="navelem"><a class="el" href="namespacekamping_1_1internal.html">internal</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
