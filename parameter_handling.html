<!-- HTML header for doxygen 1.10.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KaMPIng: Passing Parameters in KaMPIng</title>
<link rel="icon" href="icon.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeDarkModeToggle.init()
    </script>
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeFragmentCopyButton.init()
    </script>
    <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeParagraphLink.init()
    </script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="icon.svg"/></td>
  <td id="projectalign">
   <div id="projectname">KaMPIng<span id="projectnumber">&#160;0.2.1</span>
   </div>
   <div id="projectbrief">(Near) zero-overhead MPI wrapper for C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('parameter_handling.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Passing Parameters in KaMPIng</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_docs_2parameter__handling"></a> A core feature of KaMPIng is the flexible named parameters concept, allowing the caller to name and pass parameters in arbitrary order and even omit certain parameters when the library is able to infer them (at the cost of additional computation/communication). With this approach, KaMPIng allows the user a fine-grained control over the parameter set which will be explained in greater detail in this document.</p>
<p>To illustrate the concept, we first look at the function signature of <code>MPI_Alltoallv</code> as defined in MPI-4.0 which takes a <code>sendbuf</code> of variable size on each PE i and sends messages of size <code>sendcounts[j]</code> from PE i to PE j where the messages are received into <code>recvbuf</code>. Apart from these three parameters, MPI requires additional information such as the number of elements to receive (<code>recvcounts[]</code>) or possible displacements (<code>sdispls</code>, <code>rdispls</code>) etc. </p><div class="fragment"><div class="line">MPI_Alltoallv(<span class="keyword">const</span> <span class="keywordtype">void</span> *sendbuf, <span class="keyword">const</span> <span class="keywordtype">int</span> sendcounts[],</div>
<div class="line">              <span class="keyword">const</span> <span class="keywordtype">int</span> sdispls[], MPI_Datatype sendtype, <span class="keywordtype">void</span> *recvbuf,</div>
<div class="line">              <span class="keyword">const</span> <span class="keywordtype">int</span> recvcounts[], <span class="keyword">const</span> <span class="keywordtype">int</span> rdispls[],</div>
<div class="line">              MPI_Datatype recvtype, MPI_Comm comm)</div>
</div><!-- fragment --><p>In contrast to plain MPI, where the caller has to pass nine parameters to <code>MPI_Alltoallv</code>, KaMPIng requires only the <code>sendbuf</code> and <code>sendcounts</code> parameters. All other parameters are optional and are computed as follows (if omitted):</p><ul>
<li><code>recvcounts</code> are inferred through an additional call to <code>MPI_Alltoall</code> over the <code>sendcounts</code>.</li>
<li><code>sdispls</code> and <code>rdispls</code> are defaulted to an exclusive prefix sum of the <code>sendcounts</code> and <code>recvcounts</code>, respectively.</li>
<li><code>sendtype</code> and <code>recvtype</code> are inferred from the container's <code>value_type</code> storing the data to be sent (or received).</li>
</ul>
<p>As outlined above, it is possible to pass any subset of the optional parameters, in any arbitrary order, to the wrapped function call.</p>
<p>This flexibility is enabled by KaMPIng's <b>named parameter</b> approach: Each argument passed to a wrapped MPI function is identified by a name instead of its position in the complete parameter list as in plain MPI.</p>
<p>Internally, named parameters are realized as factory functions which construct parameter objects inplace, but it's easier to think of this concept in terms of <code>parameter_name(data)</code>. </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Parameter Name   </th><th class="markdownTableHeadNone">Factory Function In-Parameter   </th><th class="markdownTableHeadNone">Factory Function Out-Parameter    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">send_buf   </td><td class="markdownTableBodyNone">send_buf(...)   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">recv_buf   </td><td class="markdownTableBodyNone">-   </td><td class="markdownTableBodyNone">recv_buf_out(..)/recv_buf(...)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">send_counts   </td><td class="markdownTableBodyNone">send_counts(...)   </td><td class="markdownTableBodyNone">send_counts_out(...)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">send_displs   </td><td class="markdownTableBodyNone">send_displs(...)   </td><td class="markdownTableBodyNone">send_displs_out(...)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">recv_counts   </td><td class="markdownTableBodyNone">recv_counts(...)   </td><td class="markdownTableBodyNone">recv_counts_out(...)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">...   </td><td class="markdownTableBodyNone">...   </td><td class="markdownTableBodyNone">...   </td></tr>
</table>
<p>(See <a href="named_parameters.md#List Of Named Parameters">List of Named Parameters</a> for a list of all named parameters currently used in KaMPIng.)</p>
<p>The named parameters passed to a wrapped MPI function serve either as <em>in(put)</em> or <em>out(put)</em> parameters. Through a named <em>in</em> parameter, the caller can provide input data to the wrapped MPI call, as exemplified by <code>send_buf(data_to_send)</code> or <code>send_counts(counts)</code> with <code>data_to_send</code> and <code>counts</code> accomodating the data to be sent and send counts, respectively. Using named out parameter the caller asks KaMPIng to internally compute/infer this parameter and output its value. Named output parameters are created via the respective <code>*_out()</code> suffix. The data requested via out parameters is then either directly written to a memory location passed to the named parameter factory function or returned in a <code>std::tuple</code>-like <em>result</em> object (depending on the ownership property, see <a href="named_parameters.md#Ownership">Ownership</a>).</p>
<p>One special case is the receive buffer (<code>recv_buf(...)</code>). Although being an out parameter, it does not need to be explicitly given as KaMPIng assumes that a caller always wants to obtain this buffer.</p>
<p>See the following examples for an illustration of the different options</p>
<div class="fragment"><div class="line">std::vector&lt;T&gt; data = ...;          <span class="comment">// initialize data to send</span></div>
<div class="line">std::vector&lt;int&gt; send_counts = ...; <span class="comment">// initialize send counts</span></div>
<div class="line"> </div>
<div class="line">{</div>
<div class="line">  <span class="comment">// a single (implicit) out parameter: recv buffer</span></div>
<div class="line">  <span class="keyword">auto</span> recv_buf = comm.alltoallv(send_buf(data), send_counts(counts));</div>
<div class="line">}</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// out parameters: recv counts and recv buffer</span></div>
<div class="line">  <span class="keyword">auto</span> result = comm.alltoallv(send_buf(data), send_counts(counts), recv_counts_out());</div>
<div class="line">  std::vector&lt;T&gt;   recv_buf    = result.extract_recv_counts();</div>
<div class="line">  std::vector&lt;int&gt; recv_counts = result.extract_recv_buf();</div>
<div class="line">  <span class="comment">// or via structured bindings as auto [recv_buf, recv_counts] = comm.alltoallv(...);</span></div>
<div class="line">}</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// out parameter data is written to a specific memory location: recv counts and recv buffer</span></div>
<div class="line">  std::vector&lt;int&gt; recv_counts = ...; <span class="comment">// allocate enough memory to hold recv counts</span></div>
<div class="line">  std::vector&lt;T&gt;   recv_buffer = ...; <span class="comment">// allocate enough memory to hold recv elements</span></div>
<div class="line">  comm.alltoallv(send_buf(data),</div>
<div class="line">                 send_counts(counts),</div>
<div class="line">                 recv_counts_out(recv_counts),</div>
<div class="line">                 recv_buf_out(recv_buffer));</div>
<div class="line">}</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// out parameter data is written to a specific memory location: recv counts and recv buffer</span></div>
<div class="line">  <span class="comment">// potential resizing is done by KaMPIng</span></div>
<div class="line">  std::vector&lt;int&gt; <a class="code hl_function" href="group__kamping__named__parameters.html#gab1900a1e2bf3f92c993e34f0597d40b5">recv_counts</a>;</div>
<div class="line">  std::vector&lt;T&gt;   recv_buffer;</div>
<div class="line">  comm.alltoallv(<a class="code hl_function" href="group__kamping__named__parameters.html#gafdc0902f8c63ed8c71121f7514062de6">send_buf</a>(data),</div>
<div class="line">                 <a class="code hl_function" href="group__kamping__named__parameters.html#ga3bd3242ec8d4e270016a34e8d94de706">send_counts</a>(counts),</div>
<div class="line">                 recv_counts_out&lt;resize-to-fit&gt;(recv_counts),</div>
<div class="line">                 recv_buf_out&lt;resize-to-fit&gt;(recv_buffer));</div>
<div class="line">}</div>
<div class="ttc" id="agroup__kamping__named__parameters_html_ga3bd3242ec8d4e270016a34e8d94de706"><div class="ttname"><a href="group__kamping__named__parameters.html#ga3bd3242ec8d4e270016a34e8d94de706">kamping::params::send_counts</a></div><div class="ttdeci">auto send_counts(Container &amp;&amp;container)</div><div class="ttdoc">Passes a container as send counts to the underlying call, i.e. the container's storage must contain t...</div><div class="ttdef"><b>Definition</b> named_parameters.hpp:205</div></div>
<div class="ttc" id="agroup__kamping__named__parameters_html_gab1900a1e2bf3f92c993e34f0597d40b5"><div class="ttname"><a href="group__kamping__named__parameters.html#gab1900a1e2bf3f92c993e34f0597d40b5">kamping::params::recv_counts</a></div><div class="ttdeci">auto recv_counts(Container &amp;&amp;container)</div><div class="ttdoc">Passes a container as recv counts to the underlying call, i.e. the container's storage must contain t...</div><div class="ttdef"><b>Definition</b> named_parameters.hpp:368</div></div>
<div class="ttc" id="agroup__kamping__named__parameters_html_gafdc0902f8c63ed8c71121f7514062de6"><div class="ttname"><a href="group__kamping__named__parameters.html#gafdc0902f8c63ed8c71121f7514062de6">kamping::params::send_buf</a></div><div class="ttdeci">auto send_buf(internal::ignore_t&lt; Data &gt; ignore)</div><div class="ttdoc">Generates a dummy send buf that wraps a nullptr.</div><div class="ttdef"><b>Definition</b> named_parameters.hpp:53</div></div>
</div><!-- fragment --><p>To summarize, there are three ways to pass parameters to KaMPIng:</p><ol type="1">
<li><b>in</b> parameter: the caller directly provides the parameter required by the MPI call such as the <code>sendbuf</code>, <code>sendcounts</code>, <code>recvcounts</code> etc.</li>
<li><b>out</b> parameter: the caller does not provide the parameter but asks KaMPIng to internally compute/infer the parameter and return the value to the caller.</li>
<li><b>omitted</b> parameter: the caller does not provide the parameter and (implicitly) asks KaMPIng to internally compute/infer the parameter but is not interested in its value. Therefore it is discared once the wrapped MPI call has completed.</li>
</ol>
<p><b>Note</b>: KaMPIng will show an error message at compile time if any required parameter is missing.</p>
<p>Internally, a call to a named parameter factory function (<code>send_buf(...), send_counts(...), ...</code>) instantiates an object of the <em>DataBuffer/DataBufferBuilder</em> class encapsulating all passed data/memory and user request regarding potential output strategies.</p>
<h1><a class="anchor" id="autotoc_md42"></a>
Named Parameters and DataBuffers</h1>
<p>To fully benefit from KaMPIng's parameter flexibility, we briefly present the most important concepts of the <code>DataBuffer</code> class. A <code>DataBuffer</code> wraps either a single value or a whole underlying C++ container. In the latter case, KaMPIng requires the container to</p><ul>
<li>have contiguous memory,</li>
<li>expose its <code>value_type</code></li>
<li>have a member function <code>data()</code> returning a pointer to the start of its memory</li>
<li>have and a member function <code>size()</code> returing the container's size.</li>
</ul>
<p>If resizing of the container is requested, KaMPIng additionally requires the container to expose a <code>resize(unsigned int)</code> member function (see <a href="named_parameters.md#Resize Policy">Resize Policy</a>).</p>
<p>Futhermore, <code>DataBuffer</code> has multiple (orthogonal) properties with which the caller can control the behavior of corresponding parameter inside the wrapped MPI call:</p><ul>
<li>type: &lt;in, out, (inout)&gt;</li>
<li>ownership: &lt;owning, non-owning&gt;</li>
<li>resize-policy: &lt;no-resize, grow-only, resize-to-fit&gt;</li>
</ul>
<h2><a class="anchor" id="autotoc_md43"></a>
Parameter Type</h2>
<p>Named parameters factory functions like <code>send_counts(...)</code>, <code>recv_counts(...)</code> , ... generate <code>DataBuffers</code> with type property <em>in</em>. This signals that they wrap a container with meaningful <em>input</em> data which can be used by the MPI call directly, e.g. the send counts wrapped by <code>send_counts(...)</code>.</p>
<p>The corresponding <code>*_out</code> named parameters instantiates <code>DataBuffer</code> objects with type property <em>out</em>. They do not contain meaningful data yet and will be filled with values during the wrapped MPI call.</p>
<p><code>DataBuffers</code> with type <em>inout</em> correspond to named parameters like <code>send_recv_buf(...)</code> used in <code>MPI_Bcast</code> where data is sent on one root rank (in parameter) and received (out parameter) on all other ranks. Furthermore, passing <code>send_recv_buf(...)</code> to wrapped MPI routines such as <code>MPI_Allreduce, MPI_Allgather,...</code> indicates that the <em>inplace</em> version (<code>MPI_INPLACE</code>) will be used. See the corresponding Doxygen documentation for more information.</p>
<h2><a class="anchor" id="autotoc_md44"></a>
Ownership</h2>
<p>This property simply determines whether a <code>DataBuffer</code> owns its underlying data following the corresponding C++ ownership concept and is most important for out parameters. A <code>DataBuffer</code> <em>references</em> (<em>non</em>-owns) its container if the latter has been passed to the named parameter as an lvalue as in <code>send_buf(data)</code> or <code>recv_buf_out(recv_buffer)</code>. Otherwise a <code>DataBuffer</code> is <em>owning</em>, e.g. for <code>recv_buf_out()</code>, <code>recv_buf_out(std::move(recv_buffer))</code>.</p>
<p>Note that a named (out) parameter without associated underlying container (such as <code>recv_buf_out()</code>) implies that the caller asks KaMPIng to allocate the memory to hold the computed/infered values. This results in an owning container, which is allocated by KaMPIng and ownership is transferred to the caller upon return.</p>
<p>Furthermore, the ownership of an out parameter is important as it specifies how the computed data will be returned to the caller. Owning out parameters are moved to a result object which is returned by value. Non-owning out parameters write their data directly to their associated underlying container. Therefore, the <code>DataBuffer</code> object corresponding to this named parameter will not be part of the result object. The following code provides some example for owning and non-owning out parameters:</p>
<div class="fragment"><div class="line"><span class="comment">// owning out parameters:</span></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">auto</span> result = comm.alltoallv(send_buf(data),</div>
<div class="line">                               send_counts(counts),</div>
<div class="line">                               recv_buf_out(),</div>
<div class="line">                               recv_counts_out());</div>
<div class="line">  <span class="keyword">auto</span> recv_buffer = result.extract_recv_buffer();</div>
<div class="line">  <span class="keyword">auto</span> recv_counts = result.extract_recv_counts();</div>
<div class="line">  <span class="comment">// auto send_counts = result.extract_send_counts() // compilation error: this cannot be extracted</span></div>
<div class="line">                                                     <span class="comment">// since it is not specified as an out parameter.</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// owning out parameters with structured bindings:</span></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">auto</span> [recv_buffer, recv_counts] = comm.alltoallv(send_buf(data),</div>
<div class="line">                                                   send_counts(counts),</div>
<div class="line">                                                   recv_buf_out(),</div>
<div class="line">                                                   recv_counts_out());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// non-owning out parameters:</span></div>
<div class="line">{</div>
<div class="line">  std::vector&lt;T&gt; recv_buffer = ...; <span class="comment">// allocate sufficient memory</span></div>
<div class="line">  std::vector&lt;int&gt; recv_counts;     <span class="comment">// allocate sufficient memory</span></div>
<div class="line">  comm.alltoallv(send_buf(data),</div>
<div class="line">                 send_counts(counts),</div>
<div class="line">                 recv_buf_out(recv_buffer),</div>
<div class="line">                 recv_counts_out(recv_counts));</div>
<div class="line">}</div>
</div><!-- fragment --><p>For more information about the result object, we refer to its doxygen documentation.</p>
<h2><a class="anchor" id="autotoc_md45"></a>
Resize Policy</h2>
<p>Resize policies are important only for out parameters. They control if and how the underlying memory/container are resized if the provided memory is not large enough to hold the computed values.</p><ul>
<li><code>no_resize</code>: the underlying container is not resized and the caller has to ensure that it is large enough to hold all data.</li>
<li><code>grow_only</code>: KaMPIng will resize the underlying container if its initial size is too small. However, a container's size will never be reduced.</li>
<li><code>resize_to_fit</code>: KaMPIng will resize the underlying container to have exactly the size required to hold all data.</li>
</ul>
<p>The default resize policy is <code>no-resize</code> (except for empty named out parameters such as <code>recv_buf_out()</code> or <code>recv_counts_out()</code>). For <code>grow-only</code> or <code>resize-to-fit</code> KaMPIng requires the container to posess a member function <code>resize(unsigned integer)</code> taking an (unsigned) integer specify the requested number of elements of tye <code>value_type</code> which the container should store. Note that KaMPIng can resize <code>recv_buf</code> only if the corresponding <code>recv_type</code> matches the size of the underlying container's <code>value_type</code>. Otherwise the user must ensure that the container is large enough and only <code>no-resize</code> is allowed.</p>
<div class="fragment"><div class="line">std::vector&lt;T&gt;    recv_buffer;                </div>
<div class="line">std::vector&lt;int&gt;  recv_counts(comm.size());   </div>
<div class="line"> </div>
<div class="line">comm.alltoallv(send_buf(data),                           <span class="comment">// no resize policy necessary, as in parameters are read-only const</span></div>
<div class="line">               send_counts(counts),                      <span class="comment">// no resize policy necessary, as in parameters are read-only const</span></div>
<div class="line">               recv_buf_out&lt;resize_to_fit&gt;(recv_buffer), <span class="comment">// will be resized by KaMPIng</span></div>
<div class="line">               recv_counts_out&lt;no_resize&gt;(recv_counts)   <span class="comment">// has to be large enough to hold all recv counts</span></div>
<div class="line">              );</div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md46"></a>
List of Named Parameters</h2>
<p>In the following we give a list of all currently used named parameters in KaMPIng. </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Parameter Name   </th><th class="markdownTableHeadNone">Factory Function In-Parameter   </th><th class="markdownTableHeadNone">Factory Function Out-Parameter   </th><th class="markdownTableHeadNone">Remarks    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">send_buf   </td><td class="markdownTableBodyNone">send_buf(...)   </td><td class="markdownTableBodyNone">-   </td><td class="markdownTableBodyNone">no out parameter available as <code>send_buf</code> is the canonical input parameter    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">recv_buf   </td><td class="markdownTableBodyNone">-   </td><td class="markdownTableBodyNone">recv_buf_out(..)/recv_buf(...)   </td><td class="markdownTableBodyNone">no in parameter available as <code>recv_buf</code> is the canoncial output parameter. <code>recv_buf()</code> is an alias for <code>recv_buf_out()</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">send_recv_buf   </td><td class="markdownTableBodyNone">send_recv_buf(...)   </td><td class="markdownTableBodyNone">-   </td><td class="markdownTableBodyNone">e.g. in <code>MPI_Bcast</code> serves as send buffer on root rank and output parameter on other ranks; also used to indicate <code>MPI_INPLACE</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">send_count   </td><td class="markdownTableBodyNone">send_count(...)   </td><td class="markdownTableBodyNone">send_count_out(...)   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">send_counts   </td><td class="markdownTableBodyNone">send_counts(...)   </td><td class="markdownTableBodyNone">send_counts_out(...)   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">send_displs   </td><td class="markdownTableBodyNone">send_displs(...)   </td><td class="markdownTableBodyNone">send_displs_out(...)   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">recv_count   </td><td class="markdownTableBodyNone">recv_count(...)   </td><td class="markdownTableBodyNone">recv_count_out(...)   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">recv_counts   </td><td class="markdownTableBodyNone">recv_counts(...)   </td><td class="markdownTableBodyNone">recv_counts_out(...)   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">recv_displs   </td><td class="markdownTableBodyNone">recv_displs(...)   </td><td class="markdownTableBodyNone">recv_displs_out()   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">send_recv_count   </td><td class="markdownTableBodyNone">send_recv_count(...)   </td><td class="markdownTableBodyNone">send_recv_count_out(...)   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">op   </td><td class="markdownTableBodyNone">op(...)   </td><td class="markdownTableBodyNone">-   </td><td class="markdownTableBodyNone">encapsulates the reduction function in, for example, <code>MPI_Reduce/MPI_Allreduce</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">source   </td><td class="markdownTableBodyNone">source(...)   </td><td class="markdownTableBodyNone">-   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">destination   </td><td class="markdownTableBodyNone">destination(...)   </td><td class="markdownTableBodyNone">-   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">status   </td><td class="markdownTableBodyNone">status(...)   </td><td class="markdownTableBodyNone">status_out(...)   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">statuses   </td><td class="markdownTableBodyNone">statues(...)   </td><td class="markdownTableBodyNone">statuses_out(...)   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">request   </td><td class="markdownTableBodyNone">request(...)   </td><td class="markdownTableBodyNone">-   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">root   </td><td class="markdownTableBodyNone">root(...)   </td><td class="markdownTableBodyNone">-   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tag   </td><td class="markdownTableBodyNone">tag(...)   </td><td class="markdownTableBodyNone">-   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">send_mode   </td><td class="markdownTableBodyNone">send_mode(...)   </td><td class="markdownTableBodyNone">-   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">values_on_rank_0   </td><td class="markdownTableBodyNone">values_on_rank_0(...)   </td><td class="markdownTableBodyNone">-   </td><td class="markdownTableBodyNone">optionally encapsulates values to be used on rank 0 in <code>MPI_Exscan</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">send_type   </td><td class="markdownTableBodyNone">send_type(...)   </td><td class="markdownTableBodyNone">send_type_out(...)   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">recv_type   </td><td class="markdownTableBodyNone">recv_type(...)   </td><td class="markdownTableBodyNone">recv_type_out(...)   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">send_recv_type   </td><td class="markdownTableBodyNone">send_recv_type(...)   </td><td class="markdownTableBodyNone">send_recv_type_out(...)   </td><td class="markdownTableBodyNone"></td></tr>
</table>
<p>For further information about the usage of named parameters, we refer to the doxygen documentation of the wrapped MPI functions. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">KaMPIng Documentation Overview</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
